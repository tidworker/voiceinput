<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <!-- 在手機上自適應 -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>手寫辨識系統 (Meal 與 Custom 各自數量)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      font-family: Arial, sans-serif;
      background: black;
    }
    #appContainer {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    /* 畫布：佔 90% 螢幕寬高，背景透明 */
    canvas {
      position: absolute;
      left: 0;
      top: 0;
      width: 90vw;
      height: 90vh;
      background: transparent;
      border: none;
      z-index: 2; /* 在輸出欄之上 */
    }
    /* 建議按鈕 (浮動於上層) */
    #floatingSuggestions {
      position: absolute;
      top: 70%;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-wrap: nowrap; /* 不換行；若超出則橫向捲動 */
      overflow-x: auto;
      max-width: 95vw;
      gap: 5px;
      z-index: 10;
    }
    #floatingSuggestions button {
      background: white;
      border: 5px;
      border-radius: 3px;
      font-size: 23px;
      padding: 5px 10px;
      margin: 2px;
      white-space: nowrap; /* 不換行 */
    }
    /* 輸出欄 (textarea)：固定高度 500px，畫布下方，置中顯示 */
    #outputField {
      position: absolute;
      left: 50%;
      top: 36%;
      transform: translate(-50%, -50%);
      width: auto;
      min-width: 390px;
      height: 500px;  /* 固定高度 500px */
      padding: 5px;
      font-size: 23px;
      text-align: center;
      resize: none;
      background: transparent;
      border: none;
      outline: none;
      color: white;
      z-index: 1; /* 低於 canvas => 螢幕上顯示在後面 */
    }

    /* 浮動按鈕：固定在底部中央，可左右拖曳 */
    #dragButton {
      position: absolute;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      font-size: 20px;
      background: orange;
      border-radius: 10px;
      cursor: grab; /* 滑鼠游標顯示抓取狀態 */
      user-select: none; /* 禁止文字選取 */
      z-index: 999;
      transition: transform 0.1s; /* 拖曳時簡單的平滑過渡 */
    }
    /* 在拖曳中時，顯示抓取中狀態 */
    #dragButton:active {
      cursor: grabbing;
    }
  </style>
</head>
<body>
<div id="appContainer">
  <!-- 建議候選區 -->
  <div id="floatingSuggestions"></div>

  <!-- 透明畫布 -->
  <canvas id="canvas"></canvas>

  <!-- 輸出欄 -->
  <textarea id="outputField" readonly placeholder=""></textarea>

  <!-- 浮動按鈕 (可左右拖曳) -->
  <div id="dragButton">清除</div>
</div>

<script>
/************************************************
 * 一、四階段:
 *   0 => meals
 *   1 => amount(對應 meals)
 *   2 => custom
 *   3 => amount(對應 custom)
 ************************************************/
let currentDbIndex = 0;

// 「已完成」的品項清單 (每完成一次四階段，就放進來)
let itemList = [];
// 「目前」四階段還沒完成的文字
let currentLine = "";
// 累計總金額
let grandTotal = 0;

// 用來記錄四階段選到的標籤
//   [0] => meals label
//   [1] => meal amount
//   [2] => custom label
//   [3] => custom amount
let selectedLabels = [];

/************************************************
 * 設定：若你有放 tags.json，可用 fetch；這裡範例直接寫死
 ************************************************/
let allTags = [
  {
    category: "meals",
    name: "雞腿飯",
    price: 30,
    data: [
      { stroke: "xxx", grid: "yyy" } // 以下省略
    ]
  },
  {
    category: "custom",
    name: "加蛋",
    price: 10,
    data: [
      { stroke: "aaa", grid: "bbb" }
    ]
  },
  {
    category: "amount",
    name: "1",
    price: 1,
    data: [
      { stroke: "someStrokeFor1", grid: "someGridFor1" }
    ]
  },
  {
    category: "amount",
    name: "2",
    price: 2,
    data: [
      { stroke: "someStrokeFor2", grid: "someGridFor2" }
    ]
  },
  {
    category: "amount",
    name: "3",
    price: 3,
    data: [
      { stroke: "someStrokeFor3", grid: "someGridFor3" }
    ]
  },
  {
    category: "custom",
    name: "無",
    price: 0,
    data: [
      { stroke: "skip", grid: "skip" }
    ]
  }
];

/************************************************
 * 二、手寫畫布設定 + 筆畫 <30px => 視為無效
 ************************************************/
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

function resizeCanvasToDisplaySize() {
  const rect = canvas.getBoundingClientRect();
  canvas.width  = rect.width;
  canvas.height = rect.height;
}
window.addEventListener("resize", resizeCanvasToDisplaySize);
resizeCanvasToDisplaySize();

ctx.lineWidth   = 2;
ctx.lineCap     = "round";
ctx.strokeStyle = "gray";

// 繪製時使用
let drawing = false;
let points = [];
let recognizedStrokeText = "";
let recognizedGridText = "";
let lastCanvasImage = null;

let minX, maxX, minY, maxY;
function resetBounds(){
  minX=Infinity; maxX=-Infinity; minY=Infinity; maxY=-Infinity;
}
resetBounds();

// 取得滑鼠/觸控座標
function getPos(e){
  const rect = canvas.getBoundingClientRect();
  if(e.touches && e.touches[0]){
    return {
      x: e.touches[0].clientX - rect.left,
      y: e.touches[0].clientY - rect.top
    };
  } else {
    return {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    };
  }
}
function updateBounds(pt){
  if(pt.x<minX) minX=pt.x;
  if(pt.x>maxX) maxX=pt.x;
  if(pt.y<minY) minY=pt.y;
  if(pt.y>maxY) maxY=pt.y;
}

function startDrawing(e){
  drawing = true;
  lastCanvasImage = ctx.getImageData(0,0,canvas.width,canvas.height);
  points=[];
  resetBounds();

  const pos = getPos(e);
  points.push(pos);
  updateBounds(pos);

  ctx.beginPath();
  ctx.moveTo(pos.x, pos.y);
  e.preventDefault();
}

function draw(e){
  if(!drawing) return;
  const pos = getPos(e);
  points.push(pos);
  updateBounds(pos);

  ctx.lineTo(pos.x, pos.y);
  ctx.stroke();
  e.preventDefault();
}

function endDrawing(e){
  if(!drawing) return;
  drawing=false;

  let boxW = maxX - minX;
  let boxH = maxY - minY;
  // <30px 視為無效 => 還原
  if(boxW<30 && boxH<30){
    ctx.putImageData(lastCanvasImage,0,0);
    updateFloatingSuggestions();
    return;
  }

  // 有效筆畫 => 角度轉數字
  let strokeResult= processPointsByDistance(points);
  recognizedStrokeText += strokeResult;
  recognizedStrokeText = compressConsecutiveSequence(recognizedStrokeText);

  // 九宮格(不畫，只記錄)
  let startCell= getCell(points[0]);
  let endCell  = getCell(points[points.length-1]);
  recognizedGridText += startCell.toString() + endCell.toString();

  updateFloatingSuggestions();
  e.preventDefault();
}

// 綁定滑鼠/觸控事件
canvas.addEventListener("mousedown", startDrawing);
canvas.addEventListener("mousemove", draw);
canvas.addEventListener("mouseup",   endDrawing);
canvas.addEventListener("mouseout",  endDrawing);

canvas.addEventListener("touchstart", startDrawing, {passive:false});
canvas.addEventListener("touchmove",  draw,         {passive:false});
canvas.addEventListener("touchend",   endDrawing,   {passive:false});

/************************************************
 * 筆畫 -> 數字 (角度分段)
 ************************************************/
function getAngle(a,b){
  let dx=b.x-a.x, dy=b.y-a.y;
  let rad= Math.atan2(dy,dx);
  let deg= rad*180/Math.PI;
  if(deg<0) deg+=360;
  return deg;
}
function processPointsByDistance(pts){
  if(pts.length<2) return "";
  let result="";
  let lastSample= pts[0];
  let distSum=0;
  for(let i=1; i<pts.length; i++){
    let dx=pts[i].x-pts[i-1].x, dy=pts[i].y-pts[i-1].y;
    distSum+= Math.sqrt(dx*dx + dy*dy);
    if(distSum>=30){
      let angle= getAngle(lastSample, pts[i]);
      let raw  = Math.floor(angle/36);
      // 以 36度為一段，但這裡加了個映射 ((raw-7+10)%10) 你原本的算法
      let mapped= ((raw-7+10)%10).toString();
      result+=mapped;
      lastSample= pts[i];
      distSum=0;
    }
  }
  return result;
}
function compressConsecutiveSequence(s){
  let temp= s.replace(/(.)\1+/g, "$1");
  let r="", i=0;
  while(i<temp.length){
    let j=i+1;
    if(i<temp.length-1){
      let diff= parseInt(temp[i+1]) - parseInt(temp[i]);
      if(diff===1|| diff===-1){
        while(j<temp.length && (parseInt(temp[j]) - parseInt(temp[j-1])===diff)) j++;
        if(j-i>=3) r+= temp[i]+ temp[j-1];
        else r+= temp.slice(i,j);
        i=j;
        continue;
      }
    }
    r+= temp[i];
    i++;
  }
  return r;
}
function getCell(p){
  let edge= Math.max(maxX-minX, maxY-minY);
  let cx=(minX+maxX)/2, cy=(minY+maxY)/2;
  let left= cx-edge/2, top= cy-edge/2;
  let size= edge/3;
  let col= Math.floor((p.x-left)/size);
  let row= Math.floor((p.y-top)/size);
  if(col<0) col=0; if(col>2) col=2;
  if(row<0) row=0; if(row>2) row=2;
  return row*3+ col+1;
}

/************************************************
 * 三、浮動按鈕：左右拖動
 *   - 向左推 >= 50px => clearCanvasOnly()
 *   - 向右推 >= 50px => clearOutputAndCanvas()
 ************************************************/
const dragBtn = document.getElementById("dragButton");
let dragStartX = null;
let isDragging = false;

function onDragStart(e){
  isDragging = true;
  dragStartX = (e.touches && e.touches[0]) 
               ? e.touches[0].clientX 
               : e.clientX;
  e.preventDefault();
}
function onDragMove(e){
  if(!isDragging) return;
  let currentX = (e.touches && e.touches[0]) 
                 ? e.touches[0].clientX 
                 : e.clientX;
  let deltaX = currentX - dragStartX;
  // 讓按鈕跟著移動
  dragBtn.style.transform = `translateX(calc(-50% + ${deltaX}px))`;
  e.preventDefault();
}
function onDragEnd(e){
  if(!isDragging) return;
  isDragging = false;

  let endX = (e.changedTouches && e.changedTouches[0]) 
             ? e.changedTouches[0].clientX 
             : e.clientX;
  let deltaX = endX - dragStartX;

  // 檢查拖曳距離
  if(deltaX < -50){
    // 往左推超過 50px => 清除畫布
    clearCanvasOnly();
  } 
  else if(deltaX > 50){
    // 往右推超過 50px => 清除所有輸入
    clearOutputAndCanvas();
  }

  // 將按鈕歸位 (回到底部中央)
  dragBtn.style.transform = `translateX(-50%)`;
}

dragBtn.addEventListener("mousedown", onDragStart, {passive:false});
document.addEventListener("mousemove", onDragMove, {passive:false});
document.addEventListener("mouseup",   onDragEnd,   {passive:false});

dragBtn.addEventListener("touchstart", onDragStart, {passive:false});
document.addEventListener("touchmove", onDragMove,  {passive:false});
document.addEventListener("touchend",  onDragEnd,   {passive:false});

/************************************************
 * 四、根據 currentDbIndex 決定該用哪個 category
 ************************************************/
function getCurrentCategory(){
  // 0 => meals
  // 1 => amountMeal
  // 2 => custom
  // 3 => amountCustom
  // 這裡統一用 "amount" 這個分類標籤，但邏輯不同
  switch(currentDbIndex){
    case 0: return "meals";
    case 1: return "amount"; // for meal
    case 2: return "custom";
    case 3: return "amount"; // for custom
    default: return ""; 
  }
}

/************************************************
 * 四、只顯示前3個備選標籤 + 累計品項 + 總金額 + 當前輸入
 ************************************************/
function computeRecordDifference(sa,ga,sb,gb){
  return computeSequenceDifference(sa,sb)+ computeSequenceDifference(ga,gb);
}
function computeSequenceDifference(s1,s2){
  let ml=Math.max(s1.length,s2.length), d=0;
  for(let i=0;i<ml;i++){
    if(i<s1.length && i<s2.length){
      d += Math.abs(parseInt(s1[i]) - parseInt(s2[i]));
    } else {
      d += 3;
    }
  }
  return d;
}

function updateFloatingSuggestions(){
  const floatingDiv= document.getElementById("floatingSuggestions");
  floatingDiv.innerHTML="";

  const cat = getCurrentCategory();
  if(!cat) return;

  let tags= allTags.filter(t=> t.category === cat);
  if(tags.length===0) return;

  // 找出差異最小者
  let suggestions=[];
  tags.forEach(tag=>{
    if(tag.data && tag.data.length>0){
      let minDiff= Infinity;
      tag.data.forEach(record=>{
        let diff= computeRecordDifference(
          recognizedStrokeText, recognizedGridText,
          record.stroke, record.grid
        );
        if(diff<minDiff) minDiff= diff;
      });

      // 若 tag.name 有多個選擇 (例如 "大/小")
      // 這裡示範直接 push 單一值
      suggestions.push({
        tagName: tag.name,
        diff: minDiff,
        candidatePrice: parseFloat(tag.price),
        category: tag.category
      });
    }
  });
  // 排序 + 只取前三
  suggestions.sort((a,b)=> a.diff-b.diff);
  suggestions = suggestions.slice(0,3);

  // 建立按鈕
  suggestions.forEach(s=>{
    let btn= document.createElement("button");
    btn.textContent= s.tagName;
    btn.addEventListener("click", ()=>{
      // 若是 amount 顯示時，在文字前面加 "×"
      if(cat==="amount"){
        if(currentLine!=="") currentLine+=" ";
        currentLine += "× " + s.tagName;
      }
      else {
        // meal 或 custom
        if(currentLine!=="") currentLine+=" ";
        currentLine += s.tagName;
      }

      selectedLabels[currentDbIndex] = s;

      // 選完後，進入下一階段並清除畫布
      currentDbIndex++;
      clearCanvasOnly();

      // 若已到最後(>3) => 結算本筆
      if(currentDbIndex>3){
        finalizeOneItem();
      }

      updateOutputField();
      updateFloatingSuggestions();
    });
    floatingDiv.appendChild(btn);
  });
}

/************************************************
 * 五、結算本筆 (mealPrice×mealQty + customPrice×customQty)
 ************************************************/
function finalizeOneItem(){
  const mealLabel     = selectedLabels[0];
  const mealAmountLbl = selectedLabels[1];
  const customLabel   = selectedLabels[2];
  const custAmountLbl = selectedLabels[3];

  let mealPrice   = mealLabel?.candidatePrice     || 0;
  let mealQty     = parseFloat(mealAmountLbl?.tagName   || "0");
  let customPrice = customLabel?.candidatePrice   || 0;
  let customQty   = parseFloat(custAmountLbl?.tagName   || "0");

  let totalPrice = mealPrice*mealQty + customPrice*customQty;

  grandTotal += totalPrice;
  itemList.push(currentLine);

  // 重置
  currentLine = "";
  currentDbIndex = 0;
  selectedLabels = [];
}

/************************************************
 * 六、更新輸出欄
 ************************************************/
function updateOutputField(){
  let lines = [];
  lines = lines.concat(itemList);

  if(itemList.length>0){
    lines.push("----------");
    lines.push("總金額: " + grandTotal);
  }

  if(currentLine.trim()!==""){
    lines.push("");
    lines.push(currentLine);
  }

  document.getElementById("outputField").value = lines.join("\n");
}

/************************************************
 * 其他清除函式
 ************************************************/
function clearCanvasOnly(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  recognizedStrokeText="";
  recognizedGridText="";
  resetBounds();
  updateFloatingSuggestions();
}
function clearOutputAndCanvas(){
  itemList=[];
  currentLine="";
  grandTotal=0;
  currentDbIndex=0;
  selectedLabels=[];
  recognizedStrokeText="";
  recognizedGridText="";
  resetBounds();

  document.getElementById("outputField").value="";
  ctx.clearRect(0,0,canvas.width,canvas.height);
  updateFloatingSuggestions();
}
</script>
</body>
</html>