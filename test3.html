<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <!-- viewport 設定 -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>手持裝置手寫辨識系統 (只顯示前三個備選標籤)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 10px;
      padding: 0;
    }
    /* 畫布區 */
    canvas {
      display: block;
      margin: 0 auto 10px;
      border: 1px solid #000;
      width: 100%;
      max-width: 390px;
      height: auto;
    }
    /* 建議標籤區 */
    #floatingSuggestions {
      position: absolute; 
      top: 10px; 
      left: 10px; 
      display: flex; 
      flex-wrap: wrap; 
      gap: 5px; 
      z-index: 10;
    }
    #floatingSuggestions button {
      font-size: 14px;
      padding: 5px 10px;
      margin: 2px;
    }
    /* 輸出欄 (textarea) */
    #outputField {
      width: 90%;
      font-size: 16px;
      padding: 5px;
      margin-top: 10px;
      text-align: center;
      height: 100px;
      resize: none;
    }
    #clearOutputBtn {
      font-size: 14px;
      padding: 5px 10px;
      margin-top: 5px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h2 style="text-align:center;">手持裝置手寫辨識系統 (只顯示前三個備選標籤)</h2>
  
  <!-- 畫布與建議候選區 -->
  <div style="text-align:center; position: relative; max-width: 390px; margin: 0 auto;">
    <div id="floatingSuggestions"></div>
    <canvas id="canvas" width="390" height="390"></canvas>
  </div>
  
  <div style="text-align:center;">
    <button id="clearButton">清除畫布</button>
  </div>
  <div style="text-align:center;">
    <p>筆畫字串：<span id="resultStroke"></span></p>
    <p>九宮格字串：<span id="resultGrid"></span></p>
  </div>
  
  <!-- 輸出欄與清除按鈕 (textarea 支援換行) -->
  <div style="text-align:center;">
    <textarea id="outputField" readonly placeholder="選擇結果會顯示在此"></textarea>
    <br>
    <button id="clearOutputBtn">清除輸入欄</button>
  </div>
  
  <script>
    /******** 全域變數 ********/
    let allTags = [];  // 從伺服器讀取到的所有標籤
    let dbOrder = ['meals', 'amount', 'custom'];  // 三階段順序
    let currentDbIndex = 0;      // 目前進行的階段 (0=meals, 1=amount, 2=custom)
    let selectedLabels = [];     // 紀錄各階段選擇結果
    let grandTotal = 0;         // 累計總金額
    
    /******** 讀取伺服器上的 tags.json ********/
    // 確保 tags.json 與此 HTML 同目錄 (或對應路徑)
    // 且使用 http/https 伺服器開啟此網頁 (非 file://)
    fetch("tags.json")
      .then(response => response.json())
      .then(data => {
        allTags = data;
        updateFloatingSuggestions();
      })
      .catch(err => {
        console.error("無法取得 tags.json：", err);
      });
    
    /******** 筆畫序列壓縮 ********/
    function compressConsecutiveSequence(s) {
      let temp = s.replace(/(.)\1+/g, "$1");
      let result = "";
      let i = 0;
      while(i < temp.length) {
        let j = i + 1;
        if(i < temp.length - 1) {
          let diff = parseInt(temp[i+1]) - parseInt(temp[i]);
          if(diff === 1 || diff === -1) {
            while(j < temp.length && (parseInt(temp[j]) - parseInt(temp[j-1]) === diff)) { j++; }
            if(j - i >= 3) { result += temp[i] + temp[j-1]; }
            else { result += temp.slice(i, j); }
            i = j;
            continue;
          }
        }
        result += temp[i];
        i++;
      }
      return result;
    }
    
    /******** 手寫畫布相關變數 ********/
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    let drawing = false;
    let points = [];
    let recognizedStrokeText = "";
    let recognizedGridText = "";
    let globalMinX = Infinity, globalMaxX = -Infinity, globalMinY = Infinity, globalMaxY = -Infinity;
    
    function updateGlobalBounds(point) {
      if(point.x < globalMinX) globalMinX = point.x;
      if(point.x > globalMaxX) globalMaxX = point.x;
      if(point.y < globalMinY) globalMinY = point.y;
      if(point.y > globalMaxY) globalMaxY = point.y;
    }
    
    function getAngle(p1, p2) {
      const dx = p2.x - p1.x, dy = p2.y - p1.y;
      let rad = Math.atan2(dy, dx);
      let deg = rad * 180 / Math.PI;
      if(deg < 0) deg += 360;
      return deg;
    }
    
    // 根據移動距離分段取樣，轉成 0~9 的數字
    function processPointsByDistance() {
      let result = "";
      if(points.length < 2) return result;
      let lastSample = points[0];
      let cumulativeDistance = 0;
      for(let i = 1; i < points.length; i++){
        const dx = points[i].x - points[i-1].x;
        const dy = points[i].y - points[i-1].y;
        let dist = Math.sqrt(dx*dx + dy*dy);
        cumulativeDistance += dist;
        if(cumulativeDistance >= 30) {
          let angle = getAngle(lastSample, points[i]);
          let rawIndex = Math.floor(angle/36);
          let mappedDigit = ((rawIndex - 7 + 10) % 10).toString();
          result += mappedDigit;
          lastSample = points[i];
          cumulativeDistance = 0;
        }
      }
      return result;
    }
    
    function getPos(e) {
      const rect = canvas.getBoundingClientRect();
      if(e.touches && e.touches[0]){
        return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
      } else {
        return { x: e.clientX - rect.left, y: e.clientY - rect.top };
      }
    }
    
    function startDrawing(e) {
      drawing = true;
      points = [];
      const pos = getPos(e);
      points.push(pos);
      updateGlobalBounds(pos);
      ctx.beginPath();
      ctx.moveTo(pos.x, pos.y);
      e.preventDefault();
    }
    
    function draw(e) {
      if(!drawing) return;
      const pos = getPos(e);
      points.push(pos);
      updateGlobalBounds(pos);
      ctx.lineTo(pos.x, pos.y);
      ctx.stroke();
      e.preventDefault();
    }
    
    function endDrawing(e) {
      if(!drawing) return;
      drawing = false;
      
      let strokeResult = processPointsByDistance();
      recognizedStrokeText += strokeResult;
      recognizedStrokeText = compressConsecutiveSequence(recognizedStrokeText);
      
      if(globalMinX !== Infinity) {
        let edgeLength = Math.max(globalMaxX - globalMinX, globalMaxY - globalMinY);
        let centerX = (globalMinX + globalMaxX)/2;
        let centerY = (globalMinY + globalMaxY)/2;
        let squareLeft = centerX - edgeLength/2;
        let squareTop = centerY - edgeLength/2;
        let cellSize = edgeLength/3;
        
        function getCell(point) {
          let col = Math.floor((point.x - squareLeft)/cellSize);
          let row = Math.floor((point.y - squareTop)/cellSize);
          if(col < 0) col = 0; if(col > 2) col = 2;
          if(row < 0) row = 0; if(row > 2) row = 2;
          return row * 3 + col + 1;
        }
        
        // 起始格與結束格
        let startCell = getCell(points[0]);
        let endCell = getCell(points[points.length-1]);
        recognizedGridText += startCell.toString() + endCell.toString();
      }
      
      document.getElementById("resultStroke").textContent = recognizedStrokeText;
      document.getElementById("resultGrid").textContent = recognizedGridText;
      
      updateFloatingSuggestions();
      drawGrid();
      e.preventDefault();
    }
    
    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      points = [];
      recognizedStrokeText = "";
      recognizedGridText = "";
      document.getElementById("resultStroke").textContent = "";
      document.getElementById("resultGrid").textContent = "";
      globalMinX = Infinity; globalMaxX = -Infinity; globalMinY = Infinity; globalMaxY = -Infinity;
      updateFloatingSuggestions();
    }
    
    canvas.addEventListener("mousedown", startDrawing);
    canvas.addEventListener("mousemove", draw);
    canvas.addEventListener("mouseup", endDrawing);
    canvas.addEventListener("mouseout", endDrawing);
    
    // 觸控
    canvas.addEventListener("touchstart", startDrawing);
    canvas.addEventListener("touchmove", function(e){
      e.preventDefault();
      draw(e);
    });
    canvas.addEventListener("touchend", endDrawing);
    
    document.getElementById("clearButton").addEventListener("click", clearCanvas);
    
    function drawGrid() {
      if(globalMinX === Infinity) return;
      let edgeLength = Math.max(globalMaxX - globalMinX, globalMaxY - globalMinY);
      let centerX = (globalMinX + globalMaxX)/2;
      let centerY = (globalMinY + globalMaxY)/2;
      let squareLeft = centerX - edgeLength/2;
      let squareTop = centerY - edgeLength/2;
      let cellSize = edgeLength/3;
      
      ctx.save();
      ctx.strokeStyle = "red";
      ctx.lineWidth = 1;
      ctx.strokeRect(squareLeft, squareTop, edgeLength, edgeLength);
      ctx.beginPath();
      ctx.moveTo(squareLeft + cellSize, squareTop);
      ctx.lineTo(squareLeft + cellSize, squareTop + edgeLength);
      ctx.moveTo(squareLeft + 2*cellSize, squareTop);
      ctx.lineTo(squareLeft + 2*cellSize, squareTop + edgeLength);
      ctx.moveTo(squareLeft, squareTop + cellSize);
      ctx.lineTo(squareLeft + edgeLength, squareTop + cellSize);
      ctx.moveTo(squareLeft, squareTop + 2*cellSize);
      ctx.lineTo(squareLeft + edgeLength, squareTop + 2*cellSize);
      ctx.stroke();
      ctx.restore();
    }
    
    /******** 數字比對 ********/
    function computeSequenceDifference(seq1, seq2) {
      let maxLen = Math.max(seq1.length, seq2.length);
      let diff = 0;
      for(let i = 0; i < maxLen; i++){
        if(i < seq1.length && i < seq2.length) {
          diff += Math.abs(parseInt(seq1[i]) - parseInt(seq2[i]));
        } else {
          diff += 3; // 長度差
        }
      }
      return diff;
    }
    function computeRecordDifference(strokeA, gridA, strokeB, gridB) {
      return computeSequenceDifference(strokeA, strokeB) +
             computeSequenceDifference(gridA, gridB);
    }
    
    /******** 只顯示前 3 個備選標籤 ********/
    function updateFloatingSuggestions() {
      let currentCategory = dbOrder[currentDbIndex];
      const floatingDiv = document.getElementById("floatingSuggestions");
      floatingDiv.innerHTML = "";
      
      // 篩出同分類的標籤
      let tags = allTags.filter(tag => tag.category === currentCategory);
      if(tags.length === 0) return;
      
      // 計算 diff
      let suggestions = [];
      tags.forEach(tag => {
        // 確保有 data
        if(tag.data && tag.data.length > 0){
          let minDiff = Infinity;
          tag.data.forEach(record => {
            let diff = computeRecordDifference(
              recognizedStrokeText, recognizedGridText, 
              record.stroke, record.grid
            );
            if(diff < minDiff) minDiff = diff;
          });
          
          // 標籤若含 "/"，代表多個名稱
          if(tag.name.indexOf("/") !== -1) {
            let nameParts = tag.name.split("/");
            let priceParts = [];
            if(typeof tag.price === "string" && tag.price.indexOf("/") !== -1) {
              priceParts = tag.price.split("/");
            }
            nameParts.forEach((part, idx) => {
              let trimmed = part.trim();
              let candidatePrice = (priceParts.length > idx) ? parseFloat(priceParts[idx]) : tag.price;
              suggestions.push({
                tagName: trimmed,
                category: tag.category,
                diff: minDiff,
                candidatePrice: candidatePrice
              });
            });
          } else {
            suggestions.push({
              tagName: tag.name,
              category: tag.category,
              diff: minDiff,
              candidatePrice: tag.price
            });
          }
        }
      });
      
      // 按 diff 排序，由小到大；只顯示前3筆
      suggestions.sort((a, b) => a.diff - b.diff);
      suggestions = suggestions.slice(0, 3);
      
      // 產生按鈕 (只顯示標籤名稱)
      suggestions.forEach(s => {
        let btn = document.createElement("button");
        btn.textContent = s.tagName; // 不顯示 diff, price 或序號
        btn.addEventListener("click", function(){
          let outputField = document.getElementById("outputField");
          let currentOutput = outputField.value;
          if(currentOutput !== "") currentOutput += " / ";
          currentOutput += s.tagName;
          outputField.value = currentOutput;
          
          // 紀錄結果，進入下一階段
          selectedLabels[currentDbIndex] = s;
          currentDbIndex++;
          clearCanvas();
          
          // 若所有階段走完
          if(currentDbIndex >= dbOrder.length) {
            let mealLabel = selectedLabels[0];
            let amountLabel = selectedLabels[1];
            let total = 0;
            if(mealLabel && mealLabel.candidatePrice !== undefined && mealLabel.candidatePrice !== null) {
              let mealPrice = parseFloat(mealLabel.candidatePrice);
              let amount = parseFloat(amountLabel?.tagName);
              if(!isNaN(mealPrice) && !isNaN(amount)) {
                total = mealPrice * amount;
              }
            }
            // 顯示金額
            outputField.value += " = 總金額: " + total;
            currentDbIndex = 0;
            selectedLabels = [];
          }
          
          updateFloatingSuggestions();
        });
        floatingDiv.appendChild(btn);
      });
      
      // 如果是 custom 階段，則加一個「確定」按鈕，將本次品項金額累計到 grandTotal
      if(currentCategory === "custom") {
        let confirmBtn = document.createElement("button");
        confirmBtn.textContent = "確定";
        confirmBtn.addEventListener("click", function(){
          let outputField = document.getElementById("outputField");
          let mealLabel = selectedLabels[0];
          let amountLabel = selectedLabels[1];
          let total = 0;
          if(mealLabel && mealLabel.candidatePrice !== undefined && mealLabel.candidatePrice !== null) {
            let mealPrice = parseFloat(mealLabel.candidatePrice);
            let amount = parseFloat(amountLabel?.tagName);
            if(!isNaN(mealPrice) && !isNaN(amount)) {
              total = mealPrice * amount;
            }
          }
          grandTotal += total;
          
          let currentOutput = outputField.value;
          currentOutput += "\n= 該品項金額: " + total;
          currentOutput += "\n----------------\n累計總金額: " + grandTotal;
          outputField.value = currentOutput;
          
          // 重置回 meals 階段
          currentDbIndex = 0;
          selectedLabels = [];
          clearCanvas();
          updateFloatingSuggestions();
        });
        floatingDiv.appendChild(confirmBtn);
      }
    }
    
    /******** 清除輸入欄 ********/
    document.getElementById("clearOutputBtn").addEventListener("click", function(){
      document.getElementById("outputField").value = "";
      grandTotal = 0;
      currentDbIndex = 0;
      selectedLabels = [];
      updateFloatingSuggestions();
    });
  </script>
</body>
</html>