<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <!-- 須確保在手機上可正常顯示與縮放 -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>手持裝置手寫辨識系統</title>
  <style>
    /* 使頁面鋪滿螢幕 */
    html, body {
      margin: 0; 
      padding: 0;
      width: 100%;
      height: 100%;
      font-family: Arial, sans-serif;
    }
    #appContainer {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    /* 畫布：佔螢幕 90% 寬度 & 90% 高度，背景透明 */
    canvas {
      position: absolute;
      left: 0;
      top: 0;
      width: 90vw;  /* 90% 螢幕寬 */
      height: 90vh; /* 90% 螢幕高 */
      background: transparent;
      border: none;
      z-index: 2;  /* 在輸出欄上方 */
    }
    /* 備選按鈕：水平置中，top: 20%。
       不超過 95% 螢幕寬時，不換行；超過則自動換行或滾動 */
    #floatingSuggestions {
      position: absolute;
      top: 20%;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-wrap: nowrap;      /* 預設不換行 */
      overflow-x: auto;       /* 若超過時可水平捲動 */
      max-width: 95vw;        /* 超過 95vw，就會被捲動 */
      gap: 5px;
      z-index: 10; 
    }
    #floatingSuggestions button {
      font-size: 14px;
      padding: 5px 10px;
      margin: 2px;
      white-space: nowrap; /* 按鈕文字不換行 */
    }
    /* 輸出欄位：放在畫布之下 (z-index=1)，且位於畫面正中間 */
    #outputField {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%); /* 正中央 */
      width: auto;
      min-width: 200px; /* 可視需要微調 */
      height: auto;
      padding: 5px;
      font-size: 16px;
      text-align: center;
      resize: none;
      background: transparent;
      border: none;
      outline: none;
      color: #000;
      z-index: 1;  /* 低於 canvas => 選擇結果在背景上 */
    }
  </style>
</head>
<body>
<div id="appContainer">
  <!-- 備選按鈕 (浮動於畫面上層) -->
  <div id="floatingSuggestions"></div>

  <!-- 透明畫布 (占畫面 90%) -->
  <canvas id="canvas"></canvas>

  <!-- 輸出欄位：重疊顯示在畫面中央 (z-index=1) -->
  <textarea id="outputField" readonly placeholder="選擇結果會顯示在此"></textarea>
</div>

<script>
/************************************************
 * 一、三階段 (meals → amount → custom) + 讀取 tags.json
 ************************************************/
let dbOrder = ['meals', 'amount', 'custom'];
let currentDbIndex = 0;  // 0=meals,1=amount,2=custom
let selectedLabels = [];
let grandTotal = 0;
let allTags = [];

fetch("tags.json")
  .then(resp => resp.json())
  .then(data => {
    allTags = data;
    updateFloatingSuggestions();
  })
  .catch(err => {
    console.error("無法取得 tags.json：", err);
  });

/************************************************
 * 二、手寫畫布：佔 90vw x 90vh + 筆畫小於30px不成立
 ************************************************/
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

/* 
 * 因為使用 CSS 調整 canvas 尺寸
 * 我們需動態設定 canvas 的 實際寬高 (width/height 屬性)，
 * 否則繪圖時可能出現縮放失真
 */
function resizeCanvasToDisplaySize() {
  // getBoundingClientRect() 取得實際顯示尺寸
  const rect = canvas.getBoundingClientRect();
  canvas.width  = rect.width;
  canvas.height = rect.height;
}
window.addEventListener("resize", resizeCanvasToDisplaySize);
resizeCanvasToDisplaySize(); // 頁面載入後先執行一次

/* 筆跡設定 */
ctx.lineWidth   = 2;
ctx.lineCap     = "round";
ctx.strokeStyle = "#000";

let drawing = false;
let points = [];
let recognizedStrokeText = "";
let recognizedGridText = "";
let lastCanvasImage = null;

// 單筆畫的邊界
let minX, maxX, minY, maxY;
function resetBounds() {
  minX = Infinity; maxX = -Infinity;
  minY = Infinity; maxY = -Infinity;
}
resetBounds();

function getPos(e) {
  const rect = canvas.getBoundingClientRect();
  if(e.touches && e.touches[0]) {
    return {
      x: e.touches[0].clientX - rect.left,
      y: e.touches[0].clientY - rect.top
    };
  } else {
    return {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    };
  }
}
function updateBounds(pt){
  if(pt.x<minX) minX=pt.x;
  if(pt.x>maxX) maxX=pt.x;
  if(pt.y<minY) minY=pt.y;
  if(pt.y>maxY) maxY=pt.y;
}

// 開始繪圖
function startDrawing(e){
  drawing = true;
  // 存目前畫布影像 (若筆畫太小，還原)
  lastCanvasImage = ctx.getImageData(0,0,canvas.width,canvas.height);

  points = [];
  resetBounds();

  const pos = getPos(e);
  points.push(pos);
  updateBounds(pos);

  ctx.beginPath();
  ctx.moveTo(pos.x, pos.y);

  e.preventDefault();
}
function draw(e){
  if(!drawing) return;
  const pos = getPos(e);
  points.push(pos);
  updateBounds(pos);

  ctx.lineTo(pos.x, pos.y);
  ctx.stroke();
  e.preventDefault();
}
function endDrawing(e){
  if(!drawing) return;
  drawing = false;

  let boxW = maxX-minX, boxH = maxY-minY;
  // 若筆畫 <30px，還原
  if(boxW<30 && boxH<30){
    ctx.putImageData(lastCanvasImage, 0, 0);
    updateFloatingSuggestions();
    return;
  }
  // 否則有效筆畫
  let strokeResult = processPointsByDistance(points);
  recognizedStrokeText += strokeResult;
  recognizedStrokeText = compressConsecutiveSequence(recognizedStrokeText);

  // 九宮格(演算法，不畫)
  let startCell = getCell(points[0]);
  let endCell   = getCell(points[points.length-1]);
  recognizedGridText += startCell.toString() + endCell.toString();

  updateFloatingSuggestions();
  e.preventDefault();
}

// 監聽繪圖事件
canvas.addEventListener("mousedown", startDrawing);
canvas.addEventListener("mousemove", draw);
canvas.addEventListener("mouseup", endDrawing);
canvas.addEventListener("mouseout", endDrawing);

canvas.addEventListener("touchstart", startDrawing, {passive:false});
canvas.addEventListener("touchmove",  draw,         {passive:false});
canvas.addEventListener("touchend",   endDrawing,   {passive:false});

/* 筆畫 -> 數字 */
function getAngle(a,b){
  let dx=b.x-a.x, dy=b.y-a.y;
  let rad=Math.atan2(dy,dx);
  let deg=rad*180/Math.PI;
  if(deg<0) deg+=360;
  return deg;
}
function processPointsByDistance(pts){
  if(pts.length<2) return "";
  let result = "";
  let lastSample= pts[0];
  let distSum=0;
  for(let i=1;i<pts.length;i++){
    let dx=pts[i].x-pts[i-1].x;
    let dy=pts[i].y-pts[i-1].y;
    distSum += Math.sqrt(dx*dx + dy*dy);
    if(distSum>=30){
      let angle = getAngle(lastSample, pts[i]);
      let raw   = Math.floor(angle/36);
      let mapped= ((raw -7 +10)%10).toString();
      result+=mapped;
      lastSample= pts[i];
      distSum=0;
    }
  }
  return result;
}
/* 壓縮連續數列 */
function compressConsecutiveSequence(s){
  let temp= s.replace(/(.)\1+/g, "$1");
  let r=""; let i=0;
  while(i<temp.length){
    let j=i+1;
    if(i<temp.length-1){
      let diff= parseInt(temp[i+1]) - parseInt(temp[i]);
      if(diff===1|| diff===-1){
        while(j<temp.length && (parseInt(temp[j]) - parseInt(temp[j-1])=== diff)) j++;
        if(j-i>=3) r+= temp[i]+temp[j-1];
        else r+= temp.slice(i,j);
        i=j; 
        continue;
      }
    }
    r+= temp[i];
    i++;
  }
  return r;
}
/* 九宮格格子計算 (不畫) */
function getCell(p){
  let edge= Math.max(maxX-minX, maxY-minY);
  let cx=(minX+maxX)/2, cy=(minY+maxY)/2;
  let left= cx-edge/2, top= cy-edge/2;
  let cellSize= edge/3;
  let col= Math.floor((p.x-left)/cellSize);
  let row= Math.floor((p.y-top)/cellSize);
  if(col<0) col=0; if(col>2) col=2;
  if(row<0) row=0; if(row>2) row=2;
  return row*3 + col+1;
}

/************************************************
 * 三、長按(1秒/2秒) 清除
 ************************************************/
let pressStartTime=0, pressStartPos={x:0,y:0}, movedDuringPress=false;
function onPressStart(e){
  pressStartTime= Date.now();
  pressStartPos= getPos(e);
  movedDuringPress=false;
}
function onPressMove(e){
  let pos= getPos(e);
  let dx= pos.x-pressStartPos.x, dy= pos.y-pressStartPos.y;
  if(Math.sqrt(dx*dx+dy*dy)>10){
    movedDuringPress=true; // 視為在畫圖
  }
}
function onPressEnd(e){
  if(movedDuringPress) return;
  let dur= Date.now()- pressStartTime;
  if(dur>=2000){
    // 長按 >=2s => 清除輸入欄 & 畫布
    clearOutputAndCanvas();
  } else if(dur>=1000){
    // 長按 >=1s => 清除畫布
    clearCanvasOnly();
  }
}

function clearCanvasOnly(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  recognizedStrokeText="";
  recognizedGridText="";
  resetBounds();
  updateFloatingSuggestions();
}
function clearOutputAndCanvas(){
  document.getElementById("outputField").value="";
  grandTotal=0;
  currentDbIndex=0;
  selectedLabels=[];
  clearCanvasOnly();
}

// 全域監聽滑鼠/觸控 (長按)
document.addEventListener("mousedown", onPressStart, {passive:false});
document.addEventListener("mousemove", onPressMove,  {passive:false});
document.addEventListener("mouseup",   onPressEnd,   {passive:false});

document.addEventListener("touchstart", onPressStart, {passive:false});
document.addEventListener("touchmove",  onPressMove,  {passive:false});
document.addEventListener("touchend",   onPressEnd,   {passive:false});

/************************************************
 * 四、只顯示前3個備選標籤 + 三階段運作
 ************************************************/
function computeRecordDifference(sa, ga, sb, gb){
  return computeSequenceDifference(sa,sb) + computeSequenceDifference(ga,gb);
}
function computeSequenceDifference(s1,s2){
  let ml=Math.max(s1.length, s2.length), d=0;
  for(let i=0;i<ml;i++){
    if(i<s1.length && i<s2.length){
      d+= Math.abs(parseInt(s1[i]) - parseInt(s2[i]));
    } else {
      d+=3; // 長度差
    }
  }
  return d;
}

function updateFloatingSuggestions(){
  let currentCategory = dbOrder[currentDbIndex];
  let floatingDiv = document.getElementById("floatingSuggestions");
  floatingDiv.innerHTML="";

  let tags= allTags.filter(tag=> tag.category=== currentCategory);
  if(tags.length===0) return;

  let suggestions=[];
  tags.forEach(tag=>{
    if(tag.data && tag.data.length>0){
      let minDiff= Infinity;
      tag.data.forEach(record=>{
        let diff= computeRecordDifference(
          recognizedStrokeText, recognizedGridText,
          record.stroke, record.grid
        );
        if(diff<minDiff) minDiff=diff;
      });
      // 若 name 含 "/" => 多個子名稱
      if(tag.name.indexOf("/")!==-1){
        let nameParts= tag.name.split("/");
        let priceParts=[];
        if(typeof tag.price==="string" && tag.price.indexOf("/")!==-1){
          priceParts= tag.price.split("/");
        }
        nameParts.forEach((part,idx)=>{
          let nm= part.trim();
          let candidatePrice= (priceParts.length>idx)? parseFloat(priceParts[idx]): parseFloat(tag.price);
          suggestions.push({
            tagName: nm,
            diff: minDiff,
            candidatePrice,
            category: tag.category
          });
        });
      } else {
        suggestions.push({
          tagName: tag.name,
          diff: minDiff,
          candidatePrice: parseFloat(tag.price),
          category: tag.category
        });
      }
    }
  });

  // 排序後只取前3筆
  suggestions.sort((a,b)=> a.diff-b.diff);
  suggestions= suggestions.slice(0,3);

  // 建立候選按鈕
  suggestions.forEach(s=>{
    let btn= document.createElement("button");
    btn.textContent= s.tagName;
    btn.addEventListener("click", ()=>{
      let output= document.getElementById("outputField");
      let curVal= output.value;
      if(curVal!=="") curVal+=" / ";
      curVal+= s.tagName;
      output.value= curVal;

      selectedLabels[currentDbIndex]= s;
      currentDbIndex++;
      clearCanvasOnly();

      // 超出階段 => 結算
      if(currentDbIndex>=dbOrder.length){
        let mealLabel= selectedLabels[0];
        let amountLabel= selectedLabels[1];
        let customLabel= selectedLabels[2];
        let totalPrice= 0;
        if(mealLabel && mealLabel.candidatePrice!=null){
          let mealPrice= mealLabel.candidatePrice;
          let amtVal= parseFloat(amountLabel?.tagName|| "0");
          if(!isNaN(mealPrice) && !isNaN(amtVal)){
            totalPrice= mealPrice* amtVal;
          }
        }
        grandTotal+= totalPrice;

        // 格式: "meals × amount custom = 總金額: ???"
        let productLine= mealLabel?.tagName +" × "+ amountLabel?.tagName;
        if(customLabel) productLine+= " "+ customLabel.tagName;
        productLine+= " = 總金額: " + grandTotal;
        output.value= productLine;

        currentDbIndex=0;
        selectedLabels=[];
      }

      updateFloatingSuggestions();
    });
    floatingDiv.appendChild(btn);
  });

  // custom階段，增加一個 "確定" 按鈕 (若需多次操作)
  if(currentCategory==="custom"){
    let confirmBtn= document.createElement("button");
    confirmBtn.textContent= "確定";
    confirmBtn.addEventListener("click", ()=>{
      let output= document.getElementById("outputField");
      let mealLabel= selectedLabels[0];
      let amountLabel= selectedLabels[1];
      let customLabel= selectedLabels[2];
      let totalPrice=0;
      if(mealLabel && mealLabel.candidatePrice!=null){
        let mealPrice= mealLabel.candidatePrice;
        let amtVal= parseFloat(amountLabel?.tagName||"0");
        if(!isNaN(mealPrice) && !isNaN(amtVal)){
          totalPrice= mealPrice*amtVal;
        }
      }
      grandTotal+= totalPrice;

      let productLine= mealLabel?.tagName +" × "+ amountLabel?.tagName;
      if(customLabel) productLine+= " "+ customLabel.tagName;
      productLine+= " = 總金額: "+ grandTotal;
      output.value= productLine;

      currentDbIndex=0;
      selectedLabels=[];
      clearCanvasOnly();
      updateFloatingSuggestions();
    });
    floatingDiv.appendChild(confirmBtn);
  }
}
</script>
</body>
</html>