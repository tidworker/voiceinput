<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <!-- 使畫面適配手機裝置 -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>快速手寫輸入系統</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 10px;
      padding: 0;
    }
    h2 { text-align: center; }
    /* 建議區域，放在畫面上方 */
    #phase1Suggestions {
      display: flex;
      justify-content: space-around;
      align-items: center;
      margin: 10px auto;
      max-width: 390px;
      font-size: 18px;
    }
    #phase1Suggestions div {
      flex: 1;
      text-align: center;
      cursor: pointer;
      border: 1px solid #ccc;
      padding: 5px;
      margin: 0 5px;
      border-radius: 5px;
    }
    canvas {
      display: block;
      margin: 0 auto 10px;
      border: 1px solid #000;
      width: 100%;
      max-width: 390px;
      height: auto;
    }
    #clearButton {
      display: block;
      margin: 0 auto 10px;
      font-size: 16px;
    }
    #outputField {
      display: block;
      margin: 10px auto;
      width: 90%;
      max-width: 390px;
      padding: 8px;
      font-size: 16px;
    }
    /* Modal 樣式 (用於後續階段) */
    #modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0; top: 0;
      width: 100%; height: 100%;
      background-color: rgba(0,0,0,0.5);
    }
    .modal-content {
      background-color: #fff;
      margin: 20% auto;
      padding: 20px;
      border: 1px solid #888;
      width: 80%;
      max-width: 300px;
      text-align: center;
    }
    .modal-content button {
      margin: 5px;
      font-size: 14px;
      padding: 5px 10px;
    }
  </style>
</head>
<body>
  <h2>快速手寫輸入系統</h2>
  <!-- 第一階段建議區域：即時顯示標籤（僅 phase 1 使用） -->
  <div id="phase1Suggestions"></div>
  
  <!-- 手寫畫布 -->
  <canvas id="canvas" width="390" height="390"></canvas>
  <button id="clearButton">清除畫布</button>
  <!-- 輸出欄位 -->
  <input type="text" id="outputField" placeholder="輸入欄位..." readonly>
  
  <!-- Modal 區塊（後續階段使用） -->
  <div id="modal">
    <div class="modal-content">
      <p id="modalMessage"></p>
      <div id="modalButtons"></div>
    </div>
  </div>
  
  <script>
    /********** 全域變數與階段設定 **********/
    let phase = 1; // 1、2、3 三階段
    let currentTags = [];  // 當前階段載入的標籤資料（tagsX.json，格式為陣列，每筆 { label, stroke, grid }）
    
    // 用來記錄已完成筆畫的資料（筆畫方向與九宮格），在第一階段過程中會累計在 recognizedStrokeText / recognizedGridText 中
    let recognizedStrokeText = "";
    let recognizedGridText = "";
    
    // 全局筆畫邊界（用於九宮格計算）
    let globalMinX = Infinity, globalMaxX = -Infinity, globalMinY = Infinity, globalMaxY = -Infinity;
    function updateGlobalBounds(point) {
      if(point.x < globalMinX) globalMinX = point.x;
      if(point.x > globalMaxX) globalMaxX = point.x;
      if(point.y < globalMinY) globalMinY = point.y;
      if(point.y > globalMaxY) globalMaxY = point.y;
    }
    
    // 根據 phase 讀取對應 JSON，檔名為 tags1.json、tags2.json、tags3.json
    function loadCurrentTags(phaseNumber) {
      fetch("tags" + phaseNumber + ".json")
        .then(response => response.json())
        .then(data => { currentTags = data; })
        .catch(err => { console.error("載入 tags" + phaseNumber + ".json 失敗：", err); });
    }
    // 初始載入 phase 1 的標籤資料
    loadCurrentTags(1);
    
    /********** 手寫辨識與筆畫處理 **********/
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    let drawing = false;
    let points = [];
    
    function getPos(e) {
      const rect = canvas.getBoundingClientRect();
      if(e.touches && e.touches[0]){
        return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
      } else {
        return { x: e.clientX - rect.left, y: e.clientY - rect.top };
      }
    }
    
    function getAngle(p1, p2) {
      const dx = p2.x - p1.x, dy = p2.y - p1.y;
      let rad = Math.atan2(dy, dx);
      let deg = rad * 180 / Math.PI;
      if(deg < 0) deg += 360;
      return deg;
    }
    
    // 每累積30px取樣一次，產生筆畫字串
    function processPointsByDistance() {
      let result = "";
      if(points.length < 2) return result;
      let lastSample = points[0];
      let cumulativeDistance = 0;
      for(let i = 1; i < points.length; i++){
        const dx = points[i].x - points[i-1].x;
        const dy = points[i].y - points[i-1].y;
        let dist = Math.sqrt(dx*dx + dy*dy);
        cumulativeDistance += dist;
        if(cumulativeDistance >= 30) {
          let angle = getAngle(lastSample, points[i]);
          let rawIndex = Math.floor(angle/36);
          let mappedDigit = ((rawIndex - 7 + 10) % 10).toString();
          result += mappedDigit;
          lastSample = points[i];
          cumulativeDistance = 0;
        }
      }
      return result;
    }
    
    // 壓縮連續數列（與先前系統相同）
    function compressConsecutiveSequence(s) {
      let temp = s.replace(/(.)\1+/g, "$1");
      let result = "";
      let i = 0;
      while(i < temp.length) {
        let j = i + 1;
        if(i < temp.length - 1) {
          let diff = parseInt(temp[i+1]) - parseInt(temp[i]);
          if(diff === 1 || diff === -1) {
            while(j < temp.length && (parseInt(temp[j]) - parseInt(temp[j-1]) === diff)) { j++; }
            if(j - i >= 3) { result += temp[i] + temp[j-1]; }
            else { result += temp.slice(i, j); }
            i = j;
            continue;
          }
        }
        result += temp[i];
        i++;
      }
      return result;
    }
    
    // 畫布手寫事件
    canvas.addEventListener("mousedown", startDrawing);
    canvas.addEventListener("mousemove", draw);
    canvas.addEventListener("mouseup", endDrawing);
    canvas.addEventListener("mouseout", endDrawing);
    canvas.addEventListener("touchstart", startDrawing);
    canvas.addEventListener("touchmove", function(e){ e.preventDefault(); draw(e); });
    canvas.addEventListener("touchend", endDrawing);
    
    function startDrawing(e) {
      drawing = true;
      points = [];
      const pos = getPos(e);
      points.push(pos);
      updateGlobalBounds(pos);
      ctx.beginPath();
      ctx.moveTo(pos.x, pos.y);
      e.preventDefault();
    }
    
    function draw(e) {
      if(!drawing) return;
      const pos = getPos(e);
      points.push(pos);
      updateGlobalBounds(pos);
      ctx.lineTo(pos.x, pos.y);
      ctx.stroke();
      e.preventDefault();
      // 若處於第一階段，實時更新建議
      if(phase === 1) {
        updatePhase1Suggestions();
      }
    }
    
    // 結束筆畫後更新暫存字串（筆畫方向與九宮格）
    function endDrawing(e) {
      if(!drawing) return;
      drawing = false;
      let strokeStartPoint = points[0];
      let strokeEndPoint = points[points.length-1];
      let strokeResult = processPointsByDistance();
      recognizedStrokeText += strokeResult;
      recognizedStrokeText = compressConsecutiveSequence(recognizedStrokeText);
      // 依全局邊界計算九宮格區號
      if(globalMinX !== Infinity) {
        let edgeLength = Math.max(globalMaxX - globalMinX, globalMaxY - globalMinY);
        let centerX = (globalMinX + globalMaxX)/2, centerY = (globalMinY + globalMaxY)/2;
        let squareLeft = centerX - edgeLength/2, squareTop = centerY - edgeLength/2;
        let cellSize = edgeLength/3;
        function getCell(point) {
          let col = Math.floor((point.x - squareLeft)/cellSize);
          let row = Math.floor((point.y - squareTop)/cellSize);
          if(col < 0) col = 0; if(col > 2) col = 2;
          if(row < 0) row = 0; if(row > 2) row = 2;
          return row * 3 + col + 1;
        }
        let startCell = getCell(strokeStartPoint);
        let endCell = getCell(strokeEndPoint);
        let gridResult = startCell.toString() + endCell.toString();
        recognizedGridText += gridResult;
      }
      // 更新 phase 1 建議（即使筆畫結束也更新建議區）
      if(phase === 1) updatePhase1Suggestions();
      // 若處於 phase 2 或 3（自動選擇或模態選擇），可在 endDrawing 時進行後續處理（參考原邏輯）
      if(phase === 2) {
        // 第二階段：延遲 0.5 秒後自動選擇最佳建議
        setTimeout(() => {
          let best = getBestSuggestion();
          if(best) appendToOutput(best.label);
          phase = 3;
          loadCurrentTags(3);
        }, 500);
      }
      // 清空畫布並重置全局邊界
      clearCanvasAfterProcessing();
      e.preventDefault();
    }
    
    function clearCanvasAfterProcessing() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      points = [];
      globalMinX = Infinity; globalMaxX = -Infinity; globalMinY = Infinity; globalMaxY = -Infinity;
    }
    
    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      points = [];
      recognizedStrokeText = "";
      recognizedGridText = "";
      document.getElementById("outputField").value = "";
      globalMinX = Infinity; globalMaxX = -Infinity; globalMinY = Infinity; globalMaxY = -Infinity;
    }
    
    /********** 比對函式 **********/
    function computeSequenceDifference(seq1, seq2) {
      let maxLen = Math.max(seq1.length, seq2.length);
      let diff = 0;
      for(let i = 0; i < maxLen; i++){
        if(i < seq1.length && i < seq2.length) {
          diff += Math.abs(parseInt(seq1[i]) - parseInt(seq2[i]));
        } else {
          diff += 3;
        }
      }
      return diff;
    }
    function computeRecordDifference(strokeA, gridA, strokeB, gridB) {
      return computeSequenceDifference(strokeA, strokeB) +
             computeSequenceDifference(gridA, gridB);
    }
    
    /********** 第一階段：即時顯示建議 **********/
    // 更新 phase 1 建議區域（依據 recognizedStrokeText 與當前筆畫更新）
    function updatePhase1Suggestions() {
      if(phase !== 1) return;
      // 取目前筆畫（未完成部分）＋已完成部分
      let currentStroke = recognizedStrokeText + processPointsByDistance();
      let currentGrid = recognizedGridText; // 此階段 grid 尚未完全更新
      let suggestions = currentTags.map(record => {
        return {
          label: record.label,
          diff: computeRecordDifference(currentStroke, currentGrid, record.stroke, record.grid)
        };
      });
      suggestions.sort((a, b) => a.diff - b.diff);
      // 根據要求：第一順位（最佳）在中間，第二在左，第三在右
      let best = suggestions[0] ? suggestions[0].label : "";
      let second = suggestions[1] ? suggestions[1].label : "";
      let third = suggestions[2] ? suggestions[2].label : "";
      
      let container = document.getElementById("phase1Suggestions");
      container.innerHTML = "";
      
      // 建立三個區塊：左 (第二順位)、中 (第一順位)、右 (第三順位)
      let leftDiv = document.createElement("div");
      leftDiv.textContent = second;
      leftDiv.addEventListener("click", function() {
        if(second !== "") suggestionSelected(second);
      });
      
      let centerDiv = document.createElement("div");
      centerDiv.textContent = best;
      centerDiv.style.fontWeight = "bold";
      centerDiv.addEventListener("click", function() {
        if(best !== "") suggestionSelected(best);
      });
      
      let rightDiv = document.createElement("div");
      rightDiv.textContent = third;
      rightDiv.addEventListener("click", function() {
        if(third !== "") suggestionSelected(third);
      });
      
      container.appendChild(leftDiv);
      container.appendChild(centerDiv);
      container.appendChild(rightDiv);
    }
    
    // 取得最佳建議（用於 phase 2 自動選擇）
    function getBestSuggestion() {
      let currentStroke = recognizedStrokeText + processPointsByDistance();
      let currentGrid = recognizedGridText;
      let suggestions = currentTags.map(record => {
        return {
          label: record.label,
          diff: computeRecordDifference(currentStroke, currentGrid, record.stroke, record.grid)
        };
      });
      suggestions.sort((a, b) => a.diff - b.diff);
      return suggestions[0];
    }
    
    // 當使用者點選建議（phase 1 手動選擇）
    function suggestionSelected(selectedLabel) {
      appendToOutput(selectedLabel);
      // 清空畫布與暫存筆畫資料
      clearCanvasAfterProcessing();
      recognizedStrokeText = "";
      recognizedGridText = "";
      // 切換至第二階段
      phase = 2;
      loadCurrentTags(2);
      // 清除 phase 1 建議區域
      document.getElementById("phase1Suggestions").innerHTML = "";
    }
    
    function appendToOutput(label) {
      let outputField = document.getElementById("outputField");
      outputField.value += label;
    }
    
    /********** Modal 工具（後續階段使用） **********/
    function openModal(message, options) {
      const modal = document.getElementById("modal");
      const modalMessage = document.getElementById("modalMessage");
      const modalButtons = document.getElementById("modalButtons");
      modalMessage.textContent = message;
      modalButtons.innerHTML = "";
      options.forEach(opt => {
        const btn = document.createElement("button");
        btn.textContent = opt.label;
        btn.addEventListener("click", function() {
          opt.action();
          closeModal();
        });
        modalButtons.appendChild(btn);
      });
      modal.style.display = "block";
    }
    function closeModal() {
      document.getElementById("modal").style.display = "none";
    }
    
    /********** 第二、三階段處理 **********/
    // Phase 2：在筆畫結束後自動選擇最佳建議（延遲 0.5 秒）
    // Phase 3：採模態視窗讓使用者選擇
    // （此範例僅示意 phase 2 與 phase 3 的流程，可依需求擴充）
    
    /********** 初始設定 **********/
    // 輸出欄位為唯讀，僅由系統自動填入
  </script>
</body>
</html>