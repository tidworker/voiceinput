<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>手寫辨識</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background-color: #000;
      height: 100%;
      overflow: hidden;
    }
    /* 書寫區置中，背景黑、邊框白 */
    #mainCanvas {
      background-color: #000;
      border: 2px solid #fff;
      display: block;
      margin: 50px auto;
    }
    /* 辨識結果：36px白色文字，置頂置中 */
    #result {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 36px;
      color: #fff;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <!-- 辨識結果顯示區 -->
  <div id="result"></div>
  <!-- 書寫區 -->
  <canvas id="mainCanvas" width="390" height="500"></canvas>

  <script>
    /****************************
     * 讀取 training_data.txt *
     ****************************/
    // 讀取並解析 training_data.txt，將資料存入 localStorage（以 "label_標籤名稱" 為 key）
    fetch('training_data.txt')
      .then(response => response.text())
      .then(text => {
        try {
          const data = JSON.parse(text);
          for (const key in data) {
            if (data.hasOwnProperty(key)) {
              localStorage.setItem(key, JSON.stringify(data[key]));
            }
          }
        } catch (err) {
          console.error("讀取 training_data.txt 錯誤：", err);
        }
      })
      .catch(err => console.error("無法讀取 training_data.txt：", err));

    /***********************
     * 全域變數與初始化  *
     ***********************/
    let allStrokes = [];    // 儲存所有已完成的筆劃（每筆劃為一 array）
    let currentStroke = []; // 當前正在繪製的筆劃
    let recognitionTimeout = null; // 停止書寫後延遲辨識的計時器

    const canvas = document.getElementById("mainCanvas");
    const ctx = canvas.getContext("2d");
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 2;

    // 用來顯示辨識結果的 div
    const resultDiv = document.getElementById("result");

    /*************************
     * 畫布事件與計時辨識機制 *
     *************************/
    function getCanvasPos(evt) {
      const rect = canvas.getBoundingClientRect();
      let x, y;
      if (evt.touches) {
        x = evt.touches[0].clientX - rect.left;
        y = evt.touches[0].clientY - rect.top;
      } else {
        x = evt.clientX - rect.left;
        y = evt.clientY - rect.top;
      }
      return { x, y };
    }

    function startDrawing(evt) {
      evt.preventDefault();
      // 新的筆劃開始，清除結果與取消延遲辨識
      resultDiv.textContent = "";
      if (recognitionTimeout) {
        clearTimeout(recognitionTimeout);
        recognitionTimeout = null;
      }
      currentStroke = [];
      const pos = getCanvasPos(evt);
      currentStroke.push(pos);
      ctx.beginPath();
      ctx.moveTo(pos.x, pos.y);
    }

    function draw(evt) {
      if (!currentStroke) return;
      evt.preventDefault();
      const pos = getCanvasPos(evt);
      currentStroke.push(pos);
      ctx.lineTo(pos.x, pos.y);
      ctx.stroke();
    }

    function endDrawing(evt) {
      if (!currentStroke || currentStroke.length === 0) return;
      evt.preventDefault();
      // 完成筆劃，將其加入 allStrokes
      allStrokes.push(currentStroke);
      // 停止書寫後 0.5 秒觸發辨識
      recognitionTimeout = setTimeout(doRecognition, 500);
    }

    canvas.addEventListener("mousedown", startDrawing);
    canvas.addEventListener("mousemove", draw);
    canvas.addEventListener("mouseup", endDrawing);
    canvas.addEventListener("mouseout", endDrawing);
    canvas.addEventListener("touchstart", startDrawing);
    canvas.addEventListener("touchmove", draw);
    canvas.addEventListener("touchend", endDrawing);
    canvas.addEventListener("touchcancel", endDrawing);

    /****************************
     * 辨識系統核心函式          *
     ****************************/
    // ※ 此處採用向量變化（角度）與採樣點原始座標的比對，並加入文字端點位置檢查

    // 取得單一筆劃的簽名
    // 計算角度時以筆劃第一點正規化，但採樣後保留原始座標，讓向量變化時的位置資訊也被考慮
    function getSignature(stroke) {
      if (stroke.length < 2) return { angles: [], positions: [] };
      const origin = stroke[0];
      // 用第一點作為基準，計算正規化座標（僅用於角度計算）
      const normalized = stroke.map(pt => ({ x: pt.x - origin.x, y: pt.y - origin.y }));
      let angles = [];
      let positions = [];
      let accDistance = 0;
      let lastIndex = 0;
      // 保留第一個採樣點（採樣時使用原始座標）
      positions.push(stroke[0]);
      for (let i = 1; i < stroke.length; i++) {
        let dx = normalized[i].x - normalized[i - 1].x;
        let dy = normalized[i].y - normalized[i - 1].y;
        let dist = Math.hypot(dx, dy);
        accDistance += dist;
        if (accDistance >= 10) {  // 每累積 10px 採樣一次
          let totalDx = normalized[i].x - normalized[lastIndex].x;
          let totalDy = normalized[i].y - normalized[lastIndex].y;
          let angle = Math.atan2(totalDy, totalDx) * 180 / Math.PI;
          // 量化角度以 10 度為單位
          let quantized = Math.round(angle / 10) * 10;
          angles.push(quantized);
          // 採樣點用原始座標（未正規化），以保留向量變化的實際位置
          positions.push(stroke[i]);
          lastIndex = i;
          accDistance = 0;
        }
      }
      return { angles, positions };
    }

    // 將所有筆劃轉換為簽名，並記錄筆劃數
    function getFullSignature(strokes) {
      const strokeSignatures = strokes.map(s => getSignature(s));
      return { strokeCount: strokes.length, strokeSignatures };
    }

    // 比較單一筆劃簽名：角度差與採樣點座標差均計算
    function signatureDistance(sig1, sig2) {
      const len = Math.min(sig1.angles.length, sig2.angles.length);
      let angleDiff = 0;
      let posDiff = 0;
      for (let i = 0; i < len; i++) {
        angleDiff += Math.abs(sig1.angles[i] - sig2.angles[i]);
        let dx = sig1.positions[i].x - sig2.positions[i].x;
        let dy = sig1.positions[i].y - sig2.positions[i].y;
        posDiff += Math.hypot(dx, dy);
      }
      // 採樣點數不一致時，依差異數量加入權重
      angleDiff += Math.abs(sig1.angles.length - sig2.angles.length) * 10;
      posDiff += Math.abs(sig1.positions.length - sig2.positions.length) * 10;
      return angleDiff + posDiff;
    }

    // 取得整體繪製的端點：第一筆的第一個點與最後筆的最後一個點（使用原始座標）
    function drawingEndpoints(strokes) {
      if (strokes.length === 0) return { first: null, last: null };
      const first = strokes[0][0];
      const lastStroke = strokes[strokes.length - 1];
      const last = lastStroke[lastStroke.length - 1];
      return { first, last };
    }

    // 計算兩組繪製資料的端點距離和
    function endpointDistance(strokesA, strokesB) {
      const endpointsA = drawingEndpoints(strokesA);
      const endpointsB = drawingEndpoints(strokesB);
      if (!endpointsA.first || !endpointsB.first) return 0;
      const d1 = Math.hypot(endpointsA.first.x - endpointsB.first.x, endpointsA.first.y - endpointsB.first.y);
      const d2 = Math.hypot(endpointsA.last.x - endpointsB.last.x, endpointsA.last.y - endpointsB.last.y);
      return d1 + d2;
    }

    // 比較整體簽名：將各筆劃簽名比對結果與端點位置差異相加（取消筆劃數懲罰）
    function fullSignatureDistance(testStrokes, sampleStrokes) {
      const testSig = getFullSignature(testStrokes);
      const sampleSig = getFullSignature(sampleStrokes);
      const common = Math.min(testSig.strokeCount, sampleSig.strokeCount);
      let distance = 0;
      for (let i = 0; i < common; i++) {
        distance += signatureDistance(testSig.strokeSignatures[i], sampleSig.strokeSignatures[i]);
      }
      distance += endpointDistance(testStrokes, sampleStrokes);
      return distance;
    }

    /**********************
     * 辨識並顯示結果函式 *
     **********************/
    function doRecognition() {
      if (allStrokes.length === 0) return;
      const fullDrawing = allStrokes; // 此時 currentStroke 已結束
      let bestLabel = null;
      let bestDistance = Infinity;
      // 遍歷 localStorage 中所有以 "label_" 為前綴的訓練資料
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key.startsWith("label_")) {
          const label = key.substring(6);
          const stored = JSON.parse(localStorage.getItem(key));
          for (const sample of stored) {
            // sample 可能為 { stroke, remark } 或直接為筆劃資料
            let sampleData = sample;
            if (typeof sample === "object" && sample.stroke !== undefined) {
              sampleData = sample.stroke;
            }
            if (!sampleData || sampleData.length === 0) continue;
            const dist = fullSignatureDistance(fullDrawing, sampleData);
            if (dist < bestDistance) {
              bestDistance = dist;
              bestLabel = label;
            }
          }
        }
      }
      if (bestLabel !== null) {
        resultDiv.textContent = bestLabel;
      } else {
        resultDiv.textContent = "無訓練資料";
      }
    }

    /*******************
     * 清除畫布功能（選擇性） *
     *******************/
    // 可根據需要加入按鈕來清除 canvas 與 allStrokes
    // 例如：
    // function clearCanvas() {
    //   ctx.clearRect(0, 0, canvas.width, canvas.height);
    //   allStrokes = [];
    //   currentStroke = [];
    //   resultDiv.textContent = "";
    // }

  </script>
</body>
</html>