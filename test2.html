<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <!-- viewport 設定，確保在手機裝置上自適應 -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>快速手寫輸入系統</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 10px;
      padding: 0;
    }
    h2 { text-align: center; }
    /* Phase 1 建議區域 */
    #phase1Suggestions {
      display: flex;
      justify-content: space-around;
      align-items: center;
      margin: 10px auto;
      max-width: 390px;
      font-size: 18px;
    }
    #phase1Suggestions div {
      flex: 1;
      text-align: center;
      cursor: pointer;
      border: 1px solid #ccc;
      padding: 5px;
      margin: 0 5px;
      border-radius: 5px;
      min-height: 30px;
    }
    canvas {
      display: block;
      margin: 0 auto 10px;
      border: 1px solid #000;
      width: 100%;
      max-width: 390px;
      height: auto;
    }
    #clearButton {
      display: block;
      margin: 0 auto 10px;
      font-size: 16px;
    }
    #outputField {
      display: block;
      margin: 10px auto;
      width: 90%;
      max-width: 390px;
      padding: 8px;
      font-size: 16px;
    }
    /* Modal 樣式（後續階段使用） */
    #modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0; top: 0;
      width: 100%; height: 100%;
      background-color: rgba(0,0,0,0.5);
    }
    .modal-content {
      background-color: #fff;
      margin: 20% auto;
      padding: 20px;
      border: 1px solid #888;
      width: 80%;
      max-width: 300px;
      text-align: center;
    }
    .modal-content button {
      margin: 5px;
      font-size: 14px;
      padding: 5px 10px;
    }
  </style>
</head>
<body>
  <h2>快速手寫輸入系統</h2>
  <!-- Phase 1 建議區（僅階段 1 顯示） -->
  <div id="phase1Suggestions"></div>
  
  <!-- 手寫畫布 -->
  <canvas id="canvas" width="390" height="390"></canvas>
  <button id="clearButton">清除畫布</button>
  <!-- 輸出欄位 -->
  <input type="text" id="outputField" placeholder="輸入欄位..." readonly>
  
  <!-- Modal 區塊（供後續階段使用） -->
  <div id="modal">
    <div class="modal-content">
      <p id="modalMessage"></p>
      <div id="modalButtons"></div>
    </div>
  </div>
  
  <script>
    /********** 全域變數與階段設定 **********/
    let phase = 1; // 1、2、3 三個階段
    let currentTags = [];  // 當前階段載入的標籤資料（例如 tags1.json，格式：陣列，每筆 { label, stroke, grid }）
    
    // 用來記錄筆畫方向字串與九宮格字串（每筆 stroke 為累積結果）
    let recognizedStrokeText = "";
    let recognizedGridText = "";
    
    // 全局筆畫邊界（用於計算九宮格區號）
    let globalMinX = Infinity, globalMaxX = -Infinity, globalMinY = Infinity, globalMaxY = -Infinity;
    function updateGlobalBounds(point) {
      if(point.x < globalMinX) globalMinX = point.x;
      if(point.x > globalMaxX) globalMaxX = point.x;
      if(point.y < globalMinY) globalMinY = point.y;
      if(point.y > globalMaxY) globalMaxY = point.y;
    }
    
    // 根據 phase 讀取對應的 JSON 檔（檔名 tags1.json、tags2.json、tags3.json）
    function loadCurrentTags(phaseNumber) {
      fetch("tags" + phaseNumber + ".json")
        .then(response => response.json())
        .then(data => { currentTags = data; })
        .catch(err => { console.error("載入 tags" + phaseNumber + ".json 失敗：", err); });
    }
    // 初始載入 phase 1 的標籤資料
    loadCurrentTags(1);
    
    /********** 手寫辨識與筆畫處理 **********/
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    let drawing = false;
    let points = [];
    
    function getPos(e) {
      const rect = canvas.getBoundingClientRect();
      if(e.touches && e.touches[0]){
        return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
      } else {
        return { x: e.clientX - rect.left, y: e.clientY - rect.top };
      }
    }
    
    function getAngle(p1, p2) {
      const dx = p2.x - p1.x, dy = p2.y - p1.y;
      let rad = Math.atan2(dy, dx);
      let deg = rad * 180 / Math.PI;
      if(deg < 0) deg += 360;
      return deg;
    }
    
    // 每累積 30px 取樣一次，產生筆畫方向字串
    function processPointsByDistance() {
      let result = "";
      if(points.length < 2) return result;
      let lastSample = points[0];
      let cumulativeDistance = 0;
      for(let i = 1; i < points.length; i++){
        const dx = points[i].x - points[i-1].x;
        const dy = points[i].y - points[i-1].y;
        let dist = Math.sqrt(dx*dx + dy*dy);
        cumulativeDistance += dist;
        if(cumulativeDistance >= 30) {
          let angle = getAngle(lastSample, points[i]);
          let rawIndex = Math.floor(angle/36);
          let mappedDigit = ((rawIndex - 7 + 10) % 10).toString();
          result += mappedDigit;
          lastSample = points[i];
          cumulativeDistance = 0;
        }
      }
      return result;
    }
    
    // 壓縮連續數列函式（與先前系統相同）
    function compressConsecutiveSequence(s) {
      let temp = s.replace(/(.)\1+/g, "$1");
      let result = "";
      let i = 0;
      while(i < temp.length) {
        let j = i + 1;
        if(i < temp.length - 1) {
          let diff = parseInt(temp[i+1]) - parseInt(temp[i]);
          if(diff === 1 || diff === -1) {
            while(j < temp.length && (parseInt(temp[j]) - parseInt(temp[j-1]) === diff)) { j++; }
            if(j - i >= 3) { result += temp[i] + temp[j-1]; }
            else { result += temp.slice(i, j); }
            i = j;
            continue;
          }
        }
        result += temp[i];
        i++;
      }
      return result;
    }
    
    // 畫布手寫事件
    canvas.addEventListener("mousedown", startDrawing);
    canvas.addEventListener("mousemove", draw);
    canvas.addEventListener("mouseup", endDrawing);
    canvas.addEventListener("mouseout", endDrawing);
    canvas.addEventListener("touchstart", startDrawing);
    canvas.addEventListener("touchmove", function(e){ e.preventDefault(); draw(e); });
    canvas.addEventListener("touchend", endDrawing);
    
    function startDrawing(e) {
      drawing = true;
      points = [];
      const pos = getPos(e);
      points.push(pos);
      updateGlobalBounds(pos);
      ctx.beginPath();
      ctx.moveTo(pos.x, pos.y);
      e.preventDefault();
    }
    
    function draw(e) {
      if(!drawing) return;
      const pos = getPos(e);
      points.push(pos);
      updateGlobalBounds(pos);
      ctx.lineTo(pos.x, pos.y);
      ctx.stroke();
      e.preventDefault();
      // 若處於第一階段，實時更新建議
      if(phase === 1) {
        // 目前筆畫結果 = 已累積 recognizedStrokeText + 當前尚未結束筆畫的 processPointsByDistance()
        let currentStroke = recognizedStrokeText + processPointsByDistance();
        // 由於九宮格計算只有在結束時才能完整計算，這裡先傳入空字串
        updatePhase1Suggestions(currentStroke, "");
      }
    }
    
    function endDrawing(e) {
      if(!drawing) return;
      drawing = false;
      let strokeStartPoint = points[0];
      let strokeEndPoint = points[points.length-1];
      let strokeResult = processPointsByDistance();
      recognizedStrokeText += strokeResult;
      recognizedStrokeText = compressConsecutiveSequence(recognizedStrokeText);
      // 計算九宮格區號（以全局邊界為依據）
      if(globalMinX !== Infinity) {
        let edgeLength = Math.max(globalMaxX - globalMinX, globalMaxY - globalMinY);
        let centerX = (globalMinX + globalMaxX)/2, centerY = (globalMinY + globalMaxY)/2;
        let squareLeft = centerX - edgeLength/2, squareTop = centerY - edgeLength/2;
        let cellSize = edgeLength/3;
        function getCell(point) {
          let col = Math.floor((point.x - squareLeft)/cellSize);
          let row = Math.floor((point.y - squareTop)/cellSize);
          if(col < 0) col = 0; if(col > 2) col = 2;
          if(row < 0) row = 0; if(row > 2) row = 2;
          return row * 3 + col + 1;
        }
        let startCell = getCell(strokeStartPoint);
        let endCell = getCell(strokeEndPoint);
        let gridResult = startCell.toString() + endCell.toString();
        recognizedGridText += gridResult;
      }
      // 更新 phase 1 建議（即使筆畫結束也更新建議區）
      if(phase === 1) updatePhase1Suggestions(recognizedStrokeText, "");
      // 如果 phase 為 2 或 3，後續流程則依需求進行（此範例僅示 phase 1）
      clearCanvasAfterProcessing();
      e.preventDefault();
    }
    
    function clearCanvasAfterProcessing() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      points = [];
      // 重置全局邊界
      globalMinX = Infinity; globalMaxX = -Infinity; globalMinY = Infinity; globalMaxY = -Infinity;
    }
    
    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      points = [];
      recognizedStrokeText = "";
      recognizedGridText = "";
      document.getElementById("outputField").value = "";
      globalMinX = Infinity; globalMaxX = -Infinity; globalMinY = Infinity; globalMaxY = -Infinity;
    }
    
    /********** 比對函式 **********/
    function computeSequenceDifference(seq1, seq2) {
      let maxLen = Math.max(seq1.length, seq2.length);
      let diff = 0;
      for(let i = 0; i < maxLen; i++){
        if(i < seq1.length && i < seq2.length) {
          diff += Math.abs(parseInt(seq1[i]) - parseInt(seq2[i]));
        } else {
          diff += 3;
        }
      }
      return diff;
    }
    function computeRecordDifference(strokeA, gridA, strokeB, gridB) {
      return computeSequenceDifference(strokeA, strokeB) +
             computeSequenceDifference(gridA, gridB);
    }
    
    /********** Phase 1 即時建議 **********/
    // 更新 phase 1 建議區，參數 strokeText 與 gridText 分別代表目前筆畫的方向字串與九宮格字串
    function updatePhase1Suggestions(strokeText, gridText) {
      if(!currentTags || currentTags.length === 0) return;
      const suggestions = currentTags.map(record => {
        return {
          label: record.label,
          diff: computeRecordDifference(strokeText, gridText, record.stroke, record.grid)
        };
      });
      suggestions.sort((a, b) => a.diff - b.diff);
      // 根據要求：最佳建議在中間，第二在左，第三在右
      const best = suggestions[0] ? suggestions[0].label : "";
      const second = suggestions[1] ? suggestions[1].label : "";
      const third = suggestions[2] ? suggestions[2].label : "";
      
      const container = document.getElementById("phase1Suggestions");
      container.innerHTML = "";
      
      // 建立三個區塊
      const createDiv = (label, isBest = false) => {
        const div = document.createElement("div");
        div.textContent = label;
        if(isBest) { div.style.fontWeight = "bold"; }
        if(label) {
          div.onclick = () => { suggestionSelected(label); };
        }
        return div;
      };
      
      container.appendChild(createDiv(second));
      container.appendChild(createDiv(best, true));
      container.appendChild(createDiv(third));
    }
    
    // 使用者點選 Phase 1 建議後
    function suggestionSelected(selectedLabel) {
      appendToOutput(selectedLabel);
      recognizedStrokeText = "";
      recognizedGridText = "";
      clearCanvasAfterProcessing();
      // 切換到 Phase 2：讀取 tags2.json（此範例僅示意 Phase 1 至 2 切換）
      phase = 2;
      loadCurrentTags(2);
      // 清空 Phase 1 建議區
      document.getElementById("phase1Suggestions").innerHTML = "";
    }
    
    function appendToOutput(label) {
      let outputField = document.getElementById("outputField");
      outputField.value += label;
    }
    
    /********** Modal 工具（後續階段使用） **********/
    function openModal(message, options) {
      const modal = document.getElementById("modal");
      const modalMessage = document.getElementById("modalMessage");
      const modalButtons = document.getElementById("modalButtons");
      modalMessage.textContent = message;
      modalButtons.innerHTML = "";
      options.forEach(opt => {
        const btn = document.createElement("button");
        btn.textContent = opt.label;
        btn.addEventListener("click", function() {
          opt.action();
          closeModal();
        });
        modalButtons.appendChild(btn);
      });
      modal.style.display = "block";
    }
    function closeModal() {
      document.getElementById("modal").style.display = "none";
    }
    
    /********** 初始設定 **********/
    // 輸出欄位為唯讀
    // 當系統載入時，phase 為 1，已載入 tags1.json
  </script>
</body>
</html>