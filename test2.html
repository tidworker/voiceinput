<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="utf-8">
  <!-- 在手機上自適應 -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>手寫辨識訂單系統 + 辣度切換</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      font-family: Arial, sans-serif;
      background: black;
    }
    #appContainer {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    /* 畫布：佔 90% 螢幕寬高，背景透明 */
    canvas {
      position: absolute;
      left: 0;
      top: 0;
      width: 90vw;
      height: 90vh;
      background: transparent;
      border: none;
      z-index: 2;
    }
    /* 建議按鈕 (浮動於上層) */
    #floatingSuggestions {
      position: absolute;
      top: 70%;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-wrap: nowrap;
      overflow-x: auto;
      max-width: 95vw;
      gap: 5px;
      z-index: 10;
    }
    #floatingSuggestions button {
      background: white;
      border: 5px;
      border-radius: 3px;
      font-size: 23px;
      padding: 5px 10px;
      margin: 2px;
      white-space: nowrap;
    }
    /* 自訂工具按鈕 */
    #customToolsContainer {
      position: absolute;
      top: 80%;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      gap: 10px;
      z-index: 10;
    }
    /* 訂單列表：用 div 呈現，方便內部文字點擊變化 */
    #orderList {
      position: absolute;
      left: 50%;
      top: 36%;
      transform: translate(-50%, -50%);
      min-width: 390px;
      max-height: 500px;
      overflow-y: auto;
      padding: 5px;
      font-size: 23px;
      text-align: center;
      background: transparent;
      color: white;
      z-index: 1;
    }
    #orderList p {
      margin: 5px 0;
      cursor: pointer;
    }
    /* 浮動清除按鈕，使用 logo.png */
    #dragButton {
      position: absolute;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      font-size: 20px;
      background: transparent;
      cursor: grab;
      user-select: none;
      z-index: 999;
      transition: transform 0.1s;
    }
    #dragButton img {
      max-width: 100px;
      height: auto;
    }
    #dragButton:active {
      cursor: grabbing;
    }
  </style>
</head>
<body>
<div id="appContainer">
  <!-- 建議候選區 -->
  <div id="floatingSuggestions"></div>

  <!-- custom 階段用工具按鈕 -->
  <div id="customToolsContainer"></div>

  <!-- 透明畫布 -->
  <canvas id="canvas"></canvas>

  <!-- 訂單列表 (用於顯示訂單內容，點選內文可切換辣度) -->
  <div id="orderList"></div>

  <!-- 浮動清除按鈕 (使用 logo.png) -->
  <div id="dragButton"><img src="logo.png" alt="清除按鈕"></div>
</div>

<script>
/************************************************
 * 狀態與訂單資料設定：
 * phase：目前輸入階段
 *   "meal"：主餐品項選擇
 *   "mealQuantity"：主餐數量輸入
 *   "custom"：客製化品項選擇，可重複新增
 *   "customQuantity"：客製化數量輸入
 *
 * currentOrder：目前訂單資料
 *   { meal: {tagName, candidatePrice, quantity}, customs: [ {tagName, candidatePrice, quantity}, ... ] }
 ************************************************/
let phase = "meal";
let currentOrder = { meal: null, customs: [] };
let tempCustom = null;  // 暫存正在輸入客製化品項

// 訂單列表與累計總金額
let itemList = [];  // 每筆訂單字串
let grandTotal = 0;
let currentLine = "";  // 目前訂單顯示字串

// 記錄候選標籤資料（假設 tags.json 包含 category）
let allTags = [];
fetch("tags.json")
  .then(resp => resp.json())
  .then(data => {
    allTags = data;
    updateFloatingSuggestions();
  })
  .catch(err => {
    console.error("無法取得 tags.json：", err);
  });

/************************************************
 * 辣度切換功能整合
 * spicyStates：辣度狀態陣列
 * ordersRemark：以 ordersRemark 儲存已完成訂單的備註（包含辣度資訊）
 * 
 * 此範例中，我們將 itemList 裡的每筆訂單視為一筆 remark 字串，
 * 點選訂單字串中的「辣」關鍵字即可切換狀態。
 ************************************************/
const spicyStates = ["加辣", "小辣", "大辣"];

// cycleSpicy：根據指定的訂單索引切換最後一個辣度字串
function cycleSpicy(orderIndex) {
  if (orderIndex < 0 || orderIndex >= itemList.length) return;
  let remark = itemList[orderIndex];
  // 正則式匹配最後出現的辣度字串與後方乘數（如 x2）
  let re = /(加辣|小辣|大辣)(x\d+)?(?!.*(加辣|小辣|大辣))/;
  let match = remark.match(re);
  if (match) {
    let currentState = match[1];
    let multiplier = match[2] || "";
    let index = spicyStates.indexOf(currentState);
    let nextState = spicyStates[(index + 1) % spicyStates.length];
    remark = remark.replace(re, nextState + multiplier);
    itemList[orderIndex] = remark;
    updateOrderList();
  }
}

// 更新訂單列表顯示區（點選訂單內容可切換辣度）
function updateOrderList() {
  const orderListDiv = document.getElementById("orderList");
  orderListDiv.innerHTML = "";
  // 依序列出已完成訂單
  itemList.forEach((order, idx) => {
    let p = document.createElement("p");
    // 使用 innerHTML 讓辣度文字可點選
    p.innerHTML = order;
    p.addEventListener("click", () => cycleSpicy(idx));
    orderListDiv.appendChild(p);
  });
  // 顯示總金額（另外一行）
  if(itemList.length > 0){
    let totalP = document.createElement("p");
    totalP.innerHTML = "----------<br>總金額: " + grandTotal;
    orderListDiv.appendChild(totalP);
  }
}

/************************************************
 * 手寫畫布與筆畫處理
 ************************************************/
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
function resizeCanvasToDisplaySize() {
  const rect = canvas.getBoundingClientRect();
  canvas.width  = rect.width;
  canvas.height = rect.height;
}
window.addEventListener("resize", resizeCanvasToDisplaySize);
resizeCanvasToDisplaySize();

ctx.lineWidth   = 2;
ctx.lineCap     = "round";
ctx.strokeStyle = "gray";
let drawing = false;
let points = [];
let recognizedStrokeText = "";
let recognizedGridText = "";
let lastCanvasImage = null;
let minX, maxX, minY, maxY;
function resetBounds(){
  minX = Infinity; maxX = -Infinity; minY = Infinity; maxY = -Infinity;
}
resetBounds();
function getPos(e){
  const rect = canvas.getBoundingClientRect();
  if(e.touches && e.touches[0]){
    return {
      x: e.touches[0].clientX - rect.left,
      y: e.touches[0].clientY - rect.top
    };
  } else {
    return {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    };
  }
}
function updateBounds(pt){
  if(pt.x < minX) minX = pt.x;
  if(pt.x > maxX) maxX = pt.x;
  if(pt.y < minY) minY = pt.y;
  if(pt.y > maxY) maxY = pt.y;
}
function startDrawing(e){
  drawing = true;
  lastCanvasImage = ctx.getImageData(0,0,canvas.width,canvas.height);
  points = [];
  resetBounds();
  const pos = getPos(e);
  points.push(pos);
  updateBounds(pos);
  ctx.beginPath();
  ctx.moveTo(pos.x, pos.y);
  e.preventDefault();
}
function draw(e){
  if(!drawing) return;
  const pos = getPos(e);
  points.push(pos);
  updateBounds(pos);
  ctx.lineTo(pos.x, pos.y);
  ctx.stroke();
  e.preventDefault();
}
function endDrawing(e){
  if(!drawing) return;
  drawing = false;
  let boxW = maxX - minX, boxH = maxY - minY;
  if(boxW < 30 && boxH < 30){
    ctx.putImageData(lastCanvasImage,0,0);
    updateFloatingSuggestions();
    return;
  }
  let strokeResult = processPointsByDistance(points);
  recognizedStrokeText += strokeResult;
  recognizedStrokeText = compressConsecutiveSequence(recognizedStrokeText);
  let startCell = getCell(points[0]);
  let endCell   = getCell(points[points.length-1]);
  recognizedGridText += startCell.toString() + endCell.toString();
  updateFloatingSuggestions();
  e.preventDefault();
}
canvas.addEventListener("mousedown", startDrawing);
canvas.addEventListener("mousemove", draw);
canvas.addEventListener("mouseup", endDrawing);
canvas.addEventListener("mouseout", endDrawing);
canvas.addEventListener("touchstart", startDrawing, {passive:false});
canvas.addEventListener("touchmove", draw, {passive:false});
canvas.addEventListener("touchend", endDrawing, {passive:false});
function getAngle(a,b){
  let dx = b.x - a.x, dy = b.y - a.y;
  let rad = Math.atan2(dy, dx);
  let deg = rad * 180 / Math.PI;
  if(deg < 0) deg += 360;
  return deg;
}
function processPointsByDistance(pts){
  if(pts.length < 2) return "";
  let result = "";
  let lastSample = pts[0];
  let distSum = 0;
  for(let i = 1; i < pts.length; i++){
    let dx = pts[i].x - pts[i-1].x, dy = pts[i].y - pts[i-1].y;
    distSum += Math.sqrt(dx*dx + dy*dy);
    if(distSum >= 30){
      let angle = getAngle(lastSample, pts[i]);
      let raw = Math.floor(angle / 36);
      let mapped = ((raw - 7 + 10) % 10).toString();
      result += mapped;
      lastSample = pts[i];
      distSum = 0;
    }
  }
  return result;
}
function compressConsecutiveSequence(s){
  let temp = s.replace(/(.)\1+/g, "$1");
  let r = "", i = 0;
  while(i < temp.length){
    let j = i + 1;
    if(i < temp.length - 1){
      let diff = parseInt(temp[i+1]) - parseInt(temp[i]);
      if(diff === 1 || diff === -1){
        while(j < temp.length && (parseInt(temp[j]) - parseInt(temp[j-1]) === diff)) j++;
        if(j - i >= 3) r += temp[i] + temp[j-1];
        else r += temp.slice(i,j);
        i = j;
        continue;
      }
    }
    r += temp[i];
    i++;
  }
  return r;
}
function getCell(p){
  let edge = Math.max(maxX - minX, maxY - minY);
  let cx = (minX + maxX) / 2, cy = (minY + maxY) / 2;
  let left = cx - edge/2, top = cy - edge/2;
  let size = edge / 3;
  let col = Math.floor((p.x - left) / size);
  let row = Math.floor((p.y - top) / size);
  if(col < 0) col = 0; if(col > 2) col = 2;
  if(row < 0) row = 0; if(row > 2) row = 2;
  return row * 3 + col + 1;
}

/************************************************
 * 浮動按鈕拖曳清除功能
 ************************************************/
const dragBtn = document.getElementById("dragButton");
let dragStartX = null;
let isDragging = false;
function onDragStart(e){
  isDragging = true;
  dragStartX = (e.touches && e.touches[0]) ? e.touches[0].clientX : e.clientX;
  e.preventDefault();
}
function onDragMove(e){
  if(!isDragging) return;
  let currentX = (e.touches && e.touches[0]) ? e.touches[0].clientX : e.clientX;
  let deltaX = currentX - dragStartX;
  dragBtn.style.transform = `translateX(calc(-50% + ${deltaX}px))`;
  e.preventDefault();
}
function onDragEnd(e){
  if(!isDragging) return;
  isDragging = false;
  let endX = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0].clientX : e.clientX;
  let deltaX = endX - dragStartX;
  if(deltaX < -50) clearCanvasOnly();
  else if(deltaX > 50) clearOutputAndCanvas();
  dragBtn.style.transform = `translateX(-50%)`;
}
dragBtn.addEventListener("mousedown", onDragStart, {passive:false});
document.addEventListener("mousemove", onDragMove, {passive:false});
document.addEventListener("mouseup", onDragEnd, {passive:false});
dragBtn.addEventListener("touchstart", onDragStart, {passive:false});
document.addEventListener("touchmove", onDragMove, {passive:false});
document.addEventListener("touchend", onDragEnd, {passive:false});

/************************************************
 * 更新候選按鈕與訂單輸入邏輯
 ************************************************/
function updateFloatingSuggestions(){
  let category = "";
  if(phase === "meal") category = "meals";
  else if(phase === "mealQuantity" || phase === "customQuantity") category = "amount";
  else if(phase === "custom") category = "custom";
  
  let floatingDiv = document.getElementById("floatingSuggestions");
  floatingDiv.innerHTML = "";
  let tags = allTags.filter(t => t.category === category);
  let suggestions = [];
  tags.forEach(tag => {
    if(tag.data && tag.data.length > 0){
      let minDiff = Infinity;
      tag.data.forEach(record => {
        let diff = computeSequenceDifference(recognizedStrokeText, record.stroke) +
                   computeSequenceDifference(recognizedGridText, record.grid);
        if(diff < minDiff) minDiff = diff;
      });
      if(tag.name.indexOf("/") !== -1){
        let nameParts = tag.name.split("/");
        let priceParts = [];
        if(typeof tag.price === "string" && tag.price.indexOf("/") !== -1){
          priceParts = tag.price.split("/");
        }
        nameParts.forEach((part, idx) => {
          let nm = part.trim();
          let candidatePrice = (priceParts.length > idx) ? parseFloat(priceParts[idx]) : parseFloat(tag.price);
          suggestions.push({
            tagName: nm,
            diff: minDiff,
            candidatePrice,
            category: tag.category
          });
        });
      } else {
        suggestions.push({
          tagName: tag.name,
          diff: minDiff,
          candidatePrice: parseFloat(tag.price),
          category: tag.category
        });
      }
    }
  });
  suggestions.sort((a, b) => a.diff - b.diff);
  suggestions = suggestions.slice(0, 3);
  suggestions.forEach(s => {
    let btn = document.createElement("button");
    btn.textContent = s.tagName;
    btn.addEventListener("click", () => {
      if(phase === "meal"){
        // 選擇主餐品項
        currentOrder.meal = { tagName: s.tagName, candidatePrice: s.candidatePrice, quantity: 0 };
        currentLine = s.tagName;
        phase = "mealQuantity";
        clearCanvasOnly();
      }
      else if(phase === "mealQuantity"){
        // 選擇主餐數量
        let qty = parseFloat(s.tagName);
        currentOrder.meal.quantity = qty;
        currentLine = currentOrder.meal.tagName + " × " + qty;
        phase = "custom";
        clearCanvasOnly();
      }
      else if(phase === "custom"){
        // 選擇客製化品項，進入數量輸入階段
        tempCustom = s;
        currentLine += " + " + s.tagName;
        phase = "customQuantity";
        clearCanvasOnly();
      }
      else if(phase === "customQuantity"){
        // 輸入客製化數量
        let qty = parseFloat(s.tagName);
        currentOrder.customs.push({
          tagName: tempCustom.tagName,
          candidatePrice: tempCustom.candidatePrice,
          quantity: qty
        });
        rebuildCurrentLine();
        phase = "custom";
        tempCustom = null;
        clearCanvasOnly();
      }
      updateOrderDisplay();
      updateFloatingSuggestions();
    });
    floatingDiv.appendChild(btn);
  });
  
  // 在 customQuantity 階段，加上「完成」按鈕，
  // 按下後若未輸入數量，則預設數量取主餐數量
  if(phase === "customQuantity"){
    let finishBtn = document.createElement("button");
    finishBtn.textContent = "完成";
    finishBtn.addEventListener("click", () => {
      let defaultQty = currentOrder.meal ? currentOrder.meal.quantity : 1;
      currentOrder.customs.push({
        tagName: tempCustom.tagName,
        candidatePrice: tempCustom.candidatePrice,
        quantity: defaultQty
      });
      rebuildCurrentLine();
      phase = "custom";
      tempCustom = null;
      clearCanvasOnly();
      updateOrderDisplay();
      updateFloatingSuggestions();
    });
    floatingDiv.appendChild(finishBtn);
  }
  
  // 若在 custom 階段且主餐已選，加入「完成訂單」按鈕
  if(phase === "custom" && currentOrder.meal){
    let finishOrderBtn = document.createElement("button");
    finishOrderBtn.textContent = "完成訂單";
    finishOrderBtn.addEventListener("click", finalizeOrder);
    floatingDiv.appendChild(finishOrderBtn);
  }
}
function computeSequenceDifference(s1, s2){
  let ml = Math.max(s1.length, s2.length), d = 0;
  for(let i = 0; i < ml; i++){
    if(i < s1.length && i < s2.length){
      d += Math.abs(parseInt(s1[i]) - parseInt(s2[i]));
    } else {
      d += 3;
    }
  }
  return d;
}
function rebuildCurrentLine(){
  currentLine = currentOrder.meal.tagName + " × " + currentOrder.meal.quantity;
  currentOrder.customs.forEach(c => {
    currentLine += " + " + c.tagName + " × " + c.quantity;
  });
}

/************************************************
 * 更新訂單顯示：將已完成訂單加入 orders 並更新 orderList 區
 ************************************************/
function updateOrderDisplay(){
  // 將目前訂單加入 itemList（備註中可能包含辣度資訊）
  // 若訂單字串中尚無辣度資訊，可在後面補上預設「加辣」
  let remark = currentLine;
  if(remark.indexOf("辣") === -1) {
    remark += " 加辣";
  }
  // 先不重複加入：若 currentLine 為空，則表示正在輸入中
  if(remark.trim() !== ""){
    itemList.push(remark);
  }
  // 更新總金額
  let total = 0;
  if(currentOrder.meal){
    total += currentOrder.meal.candidatePrice * currentOrder.meal.quantity;
  }
  currentOrder.customs.forEach(c => {
    total += c.candidatePrice * c.quantity;
  });
  grandTotal += total;
  // 重置目前訂單資料
  currentOrder = { meal: null, customs: [] };
  phase = "meal";
  currentLine = "";
  updateOrderList();
}

/************************************************
 * 完成訂單 (按下完成訂單按鈕)
 ************************************************/
function finalizeOrder(){
  updateOrderDisplay();
  clearCanvasOnly();
}

/************************************************
 * 清除畫布與/或訂單輸入
 ************************************************/
function clearCanvasOnly(){
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  recognizedStrokeText = "";
  recognizedGridText = "";
  resetBounds();
  updateFloatingSuggestions();
}
function clearOutputAndCanvas(){
  itemList = [];
  currentLine = "";
  grandTotal = 0;
  currentOrder = { meal: null, customs: [] };
  phase = "meal";
  recognizedStrokeText = "";
  recognizedGridText = "";
  resetBounds();
  document.getElementById("orderList").innerHTML = "";
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  updateFloatingSuggestions();
}

/************************************************
 * 初始化：等待 DOMContentLoaded 後更新訂單列表
 ************************************************/
document.addEventListener("DOMContentLoaded", () => {
  updateOrderList();
});
</script>
</body>
</html>