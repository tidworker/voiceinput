<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=390, initial-scale=1.0">
  <title>手寫記錄與辨識 - 分軸縮小即記錄轉折點</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      background-color: #f5f5f5;
    }
    #canvas {
      border: 1px solid #333;
      width: 390px;
      height: 390px;
      touch-action: none;
    }
    #clearBtn {
      margin-top: 10px;
      padding: 10px 20px;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <canvas id="canvas" width="390" height="390"></canvas>
  <button id="clearBtn">清除</button>
  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const clearBtn = document.getElementById("clearBtn");
    let drawing = false;
    let points = [];
    const THRESHOLD = 30; // 兩記錄點間至少 30px

    // 取得畫布上相對座標
    function getCanvasPos(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      return { x: clientX - rect.left, y: clientY - rect.top };
    }

    // 清除畫布與點陣列
    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      points = [];
    }

    // 開始書寫，初始化點陣列
    function startDrawing(pos) {
      drawing = true;
      clearCanvas();
      points.push(pos);
      ctx.beginPath();
      ctx.moveTo(pos.x, pos.y);
    }

    // 書寫過程中記錄點並畫線
    function drawMove(pos) {
      if (!drawing) return;
      points.push(pos);
      ctx.lineTo(pos.x, pos.y);
      ctx.stroke();
    }

    /*
      detectTurningPoints 函式說明：
      - 以第一個點作為起始記錄點 lastTurning，並存入轉折點陣列。
      - 使用 candidate 儲存從 lastTurning 出發距離持續增加的點，
        並分別記錄相對 lastTurning 的最佳 x 與 y 距離（bestXDist, bestYDist）。
      - 當遇到新的點，其相對 lastTurning 的 x 或 y 距離未能超越先前最佳值時，
        就認為前一個 candidate 為局部轉折點（前提是 candidate 與 lastTurning 至少有 THRESHOLD 的距離）。
      - 更新 lastTurning 為 candidate，並從當前點重新開始累積。
      - 最後若迴圈結束時 candidate 與 lastTurning 不同且距離達標，也補記錄 candidate。
    */
    function detectTurningPoints(points) {
      if (points.length === 0) return [];
      
      let turningPoints = [];
      let lastTurning = points[0];
      turningPoints.push(lastTurning);
      
      // 初始化 candidate 與最佳距離
      let candidate = lastTurning;
      let bestXDist = 0;
      let bestYDist = 0;
      
      for (let i = 1; i < points.length; i++) {
        const current = points[i];
        // 分別計算 x 與 y 軸距離
        const xDist = Math.abs(current.x - lastTurning.x);
        const yDist = Math.abs(current.y - lastTurning.y);
        
        // 如果在 x 與 y 軸上均未縮小，更新候選點與最佳距離
        if (xDist >= bestXDist && yDist >= bestYDist) {
          candidate = current;
          bestXDist = xDist;
          bestYDist = yDist;
        } else {
          // 當任一軸的距離縮小時，檢查先前的 candidate 是否達到 THRESHOLD
          const candidateDist = Math.max(bestXDist, bestYDist);
          if (candidateDist >= THRESHOLD) {
            turningPoints.push(candidate);
            lastTurning = candidate;
          }
          // 從 lastTurning 重置，候選點重新設為 current
          candidate = current;
          bestXDist = Math.abs(current.x - lastTurning.x);
          bestYDist = Math.abs(current.y - lastTurning.y);
        }
      }
      
      // 迴圈結束後，若最後候選點與 lastTurning 不同且距離達標，補記錄一次
      const finalDist = Math.max(
        Math.abs(candidate.x - lastTurning.x),
        Math.abs(candidate.y - lastTurning.y)
      );
      if (finalDist >= THRESHOLD && candidate !== lastTurning) {
        turningPoints.push(candidate);
      }
      
      return turningPoints;
    }

    // 筆畫結束後進行轉折點偵測與標記
    function endDrawing() {
      if (!drawing) return;
      drawing = false;
      
      const turningPoints = detectTurningPoints(points);
      
      // 標記轉折點：用紅色圓圈與編號
      ctx.fillStyle = "red";
      ctx.font = "16px Arial";
      for (let i = 0; i < turningPoints.length; i++) {
        const pt = turningPoints[i];
        ctx.beginPath();
        ctx.arc(pt.x, pt.y, 4, 0, 2 * Math.PI);
        ctx.fill();
        ctx.fillText(i.toString(), pt.x + 6, pt.y - 6);
      }
      
      console.log("所有點：", points);
      console.log("轉折點：", turningPoints);
    }

    // Touch 事件（行動裝置）
    canvas.addEventListener("touchstart", function(e) {
      e.preventDefault();
      const touch = e.touches[0];
      const pos = getCanvasPos(touch.clientX, touch.clientY);
      startDrawing(pos);
    });
    canvas.addEventListener("touchmove", function(e) {
      e.preventDefault();
      const touch = e.touches[0];
      const pos = getCanvasPos(touch.clientX, touch.clientY);
      drawMove(pos);
    });
    canvas.addEventListener("touchend", function(e) {
      e.preventDefault();
      endDrawing();
    });

    // Mouse 事件（桌面測試）
    canvas.addEventListener("mousedown", function(e) {
      const pos = getCanvasPos(e.clientX, e.clientY);
      startDrawing(pos);
    });
    canvas.addEventListener("mousemove", function(e) {
      if (!drawing) return;
      const pos = getCanvasPos(e.clientX, e.clientY);
      drawMove(pos);
    });
    canvas.addEventListener("mouseup", function(e) {
      endDrawing();
    });
    canvas.addEventListener("mouseleave", function(e) {
      if (drawing) endDrawing();
    });

    // 清除按鈕事件
    clearBtn.addEventListener("click", function() {
      clearCanvas();
      points = [];
    });
  </script>
</body>
</html>