<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=390, initial-scale=1.0">
  <title>手寫記錄與辨識模組 - 依 x 或 y 軸距離紀錄轉折點</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      background-color: #f5f5f5;
    }
    #canvas {
      border: 1px solid #333;
      width: 390px;
      height: 390px;
      touch-action: none;
    }
    #clearBtn {
      margin-top: 10px;
      padding: 10px 20px;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <canvas id="canvas" width="390" height="390"></canvas>
  <button id="clearBtn">清除</button>
  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const clearBtn = document.getElementById("clearBtn");
    let drawing = false;
    let points = [];
    const threshold = 5;  // 5px 閾值

    // 取得畫布上的相對座標
    function getCanvasPos(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      return { x: clientX - rect.left, y: clientY - rect.top };
    }

    // 清除畫布與點陣列
    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      points = [];
    }

    // 開始書寫：初始化點陣列與起點
    function startDrawing(pos) {
      drawing = true;
      clearCanvas();
      points.push(pos);
      ctx.beginPath();
      ctx.moveTo(pos.x, pos.y);
    }

    // 書寫過程中依序記錄點並畫線
    function drawMove(pos) {
      if (!drawing) return;
      points.push(pos);
      ctx.lineTo(pos.x, pos.y);
      ctx.stroke();
    }

    /* 
      偵測轉折點邏輯：
      - 以第一個點作為 lastRecorded 並記錄下。
      - 從第二個點開始，計算與 lastRecorded 之「x 或 y 軸最大差距」(d)。
      - 當 d 持續增長時更新 candidate；當發現 d 開始縮短時，
        若候選點與 lastRecorded 的距離（d）達到或超過 threshold (5px) 時，
        記錄 candidate 為轉折點，並以其作為新的 lastRecorded。
      - 最後再檢查一次最後候選點。
    */
    function detectTurningPoints(points) {
      let turningPoints = [];
      if (points.length === 0) return turningPoints;
      
      let lastRecorded = points[0];
      turningPoints.push(lastRecorded);
      
      let candidate = lastRecorded;
      let prevD = 0;
      
      for (let i = 1; i < points.length; i++) {
        let current = points[i];
        // 計算與 lastRecorded 之「x 或 y 軸最大差距」
        let d = Math.max(Math.abs(current.x - lastRecorded.x), Math.abs(current.y - lastRecorded.y));
        
        if (d >= prevD) {
          candidate = current;
          prevD = d;
        } else {
          // 當距離開始縮短時，若前一區段中候選點與 lastRecorded 間距 >= threshold，才記錄
          if (prevD >= threshold) {
            turningPoints.push(candidate);
            lastRecorded = candidate;
          }
          candidate = current;
          prevD = Math.max(Math.abs(current.x - lastRecorded.x), Math.abs(current.y - lastRecorded.y));
        }
      }
      
      // 檢查筆畫結束時最後候選點與 lastRecorded 的距離是否達標
      let finalD = Math.max(Math.abs(candidate.x - lastRecorded.x), Math.abs(candidate.y - lastRecorded.y));
      if (finalD >= threshold && (candidate.x !== lastRecorded.x || candidate.y !== lastRecorded.y)) {
        turningPoints.push(candidate);
      }
      
      return turningPoints;
    }

    // 筆畫結束後進行轉折點偵測與標記
    function endDrawing() {
      if (!drawing) return;
      drawing = false;
      
      const turningPoints = detectTurningPoints(points);
      
      // 標記轉折點：紅色文字標示編號
      ctx.fillStyle = "red";
      ctx.font = "16px Arial";
      for (let i = 0; i < turningPoints.length; i++) {
        const pt = turningPoints[i];
        ctx.fillText(i.toString(), pt.x, pt.y);
      }
      
      console.log("所有點：", points);
      console.log("偵測到的轉折點：", turningPoints);
    }

    // Touch 事件（行動裝置）
    canvas.addEventListener("touchstart", function(e) {
      e.preventDefault();
      const touch = e.touches[0];
      const pos = getCanvasPos(touch.clientX, touch.clientY);
      startDrawing(pos);
    });
    canvas.addEventListener("touchmove", function(e) {
      e.preventDefault();
      const touch = e.touches[0];
      const pos = getCanvasPos(touch.clientX, touch.clientY);
      drawMove(pos);
    });
    canvas.addEventListener("touchend", function(e) {
      e.preventDefault();
      endDrawing();
    });

    // Mouse 事件（桌面測試）
    canvas.addEventListener("mousedown", function(e) {
      const pos = getCanvasPos(e.clientX, e.clientY);
      startDrawing(pos);
    });
    canvas.addEventListener("mousemove", function(e) {
      if (!drawing) return;
      const pos = getCanvasPos(e.clientX, e.clientY);
      drawMove(pos);
    });
    canvas.addEventListener("mouseup", function(e) {
      endDrawing();
    });
    canvas.addEventListener("mouseleave", function(e) {
      if (drawing) endDrawing();
    });

    // 清除按鈕事件
    clearBtn.addEventListener("click", function() {
      clearCanvas();
      points = [];
    });
  </script>
</body>
</html>