<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=390, initial-scale=1.0">
  <title>手寫記錄與辨識模組 - X或Y軸最大距離</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      background-color: #f5f5f5;
    }
    #canvas {
      border: 1px solid #333;
      width: 390px;
      height: 390px;
      touch-action: none;
    }
    #clearBtn {
      margin-top: 10px;
      padding: 10px 20px;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <canvas id="canvas" width="390" height="390"></canvas>
  <button id="clearBtn">清除</button>
  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const clearBtn = document.getElementById("clearBtn");

    let drawing = false;
    let points = [];

    // 取得畫布上相對座標
    function getCanvasPos(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      return { x: clientX - rect.left, y: clientY - rect.top };
    }

    // 清除畫布與點陣列
    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      points = [];
    }

    // 開始書寫：初始化點陣列與起點
    function startDrawing(pos) {
      drawing = true;
      clearCanvas();
      points.push(pos);
      ctx.beginPath();
      ctx.moveTo(pos.x, pos.y);
    }

    // 書寫過程中依序記錄點並畫線
    function drawMove(pos) {
      if (!drawing) return;
      points.push(pos);
      ctx.lineTo(pos.x, pos.y);
      ctx.stroke();
    }

    // 筆畫結束後進行轉折點偵測與標記
    function endDrawing() {
      if (!drawing) return;
      drawing = false;
      
      const turningPoints = detectTurningPoints(points);
      
      ctx.fillStyle = "red";
      ctx.font = "16px Arial";
      
      // 依序標記偵測到的轉折點（從 0 開始編號）
      for (let i = 0; i < turningPoints.length; i++) {
        const pt = turningPoints[i];
        ctx.fillText(i.toString(), pt.x, pt.y);
      }
      
      console.log("所有點：", points);
      console.log("偵測到的轉折點：", turningPoints);
    }

    /* 
      偵測轉折點邏輯（以 x 或 y 軸最大距離比較，門檻值 5px）：
      
      - 以第一個點作為 lastRecorded（同時記錄為第一個轉折點）。
      - 從第二個點開始，計算每個點與 lastRecorded 的距離：
            d = max(|current.x - lastRecorded.x|, |current.y - lastRecorded.y|)
      - 如果 d 值持續上升，則更新 candidate 為該點（candidate 代表目前區段中與 lastRecorded 差距最大的點）。
      - 當遇到 d 值下降時，若 candidate 與 lastRecorded 的距離大於等於門檻（5px），就記錄 candidate 為轉折點，並更新 lastRecorded 為 candidate，再重新開始比較。
      - 筆畫結束時，若最後的 candidate 與 lastRecorded 的距離達標，也記錄之。
    */
    function detectTurningPoints(points) {
      const threshold = 5;
      let turningPoints = [];
      if (points.length === 0) return turningPoints;
      
      // 記錄第一個點為起點
      let lastRecorded = points[0];
      turningPoints.push(lastRecorded);
      
      let candidate = points[0];
      let prevD = 0; // 前一個候選的距離
      for (let i = 1; i < points.length; i++) {
        let current = points[i];
        let d = Math.max(Math.abs(current.x - lastRecorded.x), Math.abs(current.y - lastRecorded.y));
        
        // 如果目前的 d 值大於等於前一個候選值，更新 candidate
        if (d >= prevD) {
          candidate = current;
          prevD = d;
        } else {
          // d 值下降，表示候選點已達局部最大
          if (prevD >= threshold && (candidate.x !== lastRecorded.x || candidate.y !== lastRecorded.y)) {
            turningPoints.push(candidate);
            lastRecorded = candidate;
          }
          // 重置 candidate 與 prevD
          candidate = current;
          prevD = Math.max(Math.abs(current.x - lastRecorded.x), Math.abs(current.y - lastRecorded.y));
        }
      }
      
      // 筆畫結束時，檢查最後的 candidate
      let finalD = Math.max(Math.abs(candidate.x - lastRecorded.x), Math.abs(candidate.y - lastRecorded.y));
      if (finalD >= threshold && (candidate.x !== lastRecorded.x || candidate.y !== lastRecorded.y)) {
        turningPoints.push(candidate);
      }
      
      return turningPoints;
    }

    // Touch 事件（行動裝置）
    canvas.addEventListener("touchstart", function(e) {
      e.preventDefault();
      const touch = e.touches[0];
      const pos = getCanvasPos(touch.clientX, touch.clientY);
      startDrawing(pos);
    });
    canvas.addEventListener("touchmove", function(e) {
      e.preventDefault();
      const touch = e.touches[0];
      const pos = getCanvasPos(touch.clientX, touch.clientY);
      drawMove(pos);
    });
    canvas.addEventListener("touchend", function(e) {
      e.preventDefault();
      endDrawing();
    });

    // Mouse 事件（桌面測試）
    canvas.addEventListener("mousedown", function(e) {
      const pos = getCanvasPos(e.clientX, e.clientY);
      startDrawing(pos);
    });
    canvas.addEventListener("mousemove", function(e) {
      if (!drawing) return;
      const pos = getCanvasPos(e.clientX, e.clientY);
      drawMove(pos);
    });
    canvas.addEventListener("mouseup", function(e) {
      endDrawing();
    });
    canvas.addEventListener("mouseleave", function(e) {
      if (drawing) endDrawing();
    });

    // 清除按鈕事件
    clearBtn.addEventListener("click", function() {
      clearCanvas();
      points = [];
    });
  </script>
</body>
</html>